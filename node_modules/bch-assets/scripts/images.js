const folder = './images';
const animationsFolder = './animations';
const fs = require('fs');
const path = require('path');
const sortobject = require('deep-sort-object');
const beautify = require('js-beautify').js;

/**
 * busca archivos dentro de una carpeta, y este puede ser
 * recursivo
 * @param {*} dir directorio
 * @param {*} suffix extension
 * @param {*} callback funcion a manejar la respuesta.
 */
const scan = (dir, filelist = []) => {
    fs.readdirSync(dir).forEach(file => {
        filelist = fs.statSync(path.join(dir, file)).isDirectory()
            ? scan(path.join(dir, file), filelist)
            : filelist.concat(path.join(dir, file));
    });
    return filelist;
}
/**
 * @param  {} name
 * Recibe un nombre como par치metro y reemplaza todos los caracteres '-' y
 * los reemplaza por '_'
 */
const replaceSeparator = (name) => {
    return name.replace(/-/g, '_');
};
/**
 * @param  {} name
 * Recibe un nombre como par치metro y le elimina la extensi칩n si existe
 */
const removeExtension = (name) => {
    if (name.split('.') > 1) {
        return replaceSeparator(name.substring(0, name.length - 4));
    }
    return replaceSeparator(name);
};

const getAnimations = () => {
    let array = [];
    array = scan(animationsFolder)
    return Array.from(new Set(array));
}
/**
 * Convierta una estructura de directorio en un JSON
 * recursivo
 * @param {*} dir directorio
 * @param {*} done funcion a manejar la respuesta.
 */
const generateImages = (dir, done) => {
    var results = {};

    fs.readdir(dir, function (err, list) {
        if (err)
            return done(err);

        var pending = list.length;

        if (!pending)
            return done(null, { [path.basename(file)]: res });

        list.forEach(function (file) {
            file = path.resolve(dir, file);
            fs.stat(file, function (err, stat) {
                if (stat && stat.isDirectory()) {
                    generateImages(file, function (err, res) {
                        results[`'${path.basename(file)}'`] = res;
                        if (!--pending)
                            done(null, results);
                    });
                }
                else {
                    const to = file.indexOf('images/');
                    const relativePath = file.substring(to, file.length);
                    if (!file.includes('@')){
                        if (file.endsWith('.png')) 
                        results[`'${path.basename(file, '.png')}'`] = `require('./${relativePath}')`;
                        if (file.endsWith('.jpg'))
                        results[`'${path.basename(file, '.jpg')}'`] = `require('./${relativePath}')`;
                    }
                    if (!--pending)
                        done(null, results);
                }
            });
        });
    });
};

generateImages(folder, function (err, res) {
    /**
    * Crea un arreglo de objectos de los archivos existentes en la carpeta animations,
    * realizando excepciones como:
    * 1. Agregar solo aquellos archivos que terminen en la extensi칩n json
    */
    const animationsString = getAnimations()
        .filter((file) => {
            return file.endsWith('.json');
        })
        .map((path) => {
            let fileArray = path.split("/");
            let file = fileArray[fileArray.length - 1].replace('.json', '');
            return `"${removeExtension(file)}": { ios : require('./${path}'), android: "${path}"}`;
        })
        .join(',\n');

    const imagesString = JSON.stringify(sortobject(res)).replace(/["]+/g, '');

    const string = `
    const lottieAnimations = { ${animationsString} };
    const icoMoonConfig = require('./fonts/selection.json');
    const Images = ${imagesString};
    const assets = {
        ...Images,
        lottieAnimations,
        icoMoonConfig,
    };
    export default assets;
    
    `;

    if (err)
        console.error(err);
    fs.writeFileSync('index.js', beautify(string, { indent_size: 4, space_in_empty_paren: true }), 'utf8');
});
