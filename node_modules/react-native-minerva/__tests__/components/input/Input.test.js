import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { HelperStyle, Text, H3 } from '../../../src/index';
import buildStyles from '../../../src/components/input/style';
import Input from '../../../src/components/input/Input';
import { inputDefaultProps } from '../../../src/components/input/type';
import INPUT_STR from '../../../src/components/input/inputStr';

describe('Test componente <Input />', () => {
    const textLeft = '+569';
    const textRight = 'suffix text';
    const mockOnFocus = jest.fn();
    const mockOnBlur = jest.fn();
    const props = {
        label: 'Inpur',
        value: 'text',
        testID: 'testID_input',
        onChangeText: jest.fn(),
        disabled: true,
        renderLeft: () => <H3 number>{textLeft}</H3>,
        renderRight: () => <Text>{textRight}</Text>,
        helperText: 'mensaje',
        maxLength: 100,
    };
    test('Debería renderizar correctamente', () => {
        const { label, onChangeText } = props;
        const { toJSON } = render(
            <Input label={label} value="" onChangeText={onChangeText} />,
        );
        expect(toJSON()).toMatchSnapshot();
    });

    test('Debería estar en estado completado y label ser fontSize type_2', () => {
        const { label, value, testID, onChangeText } = props;
        const { getByTestId } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
            />,
        );
        const inputElement = getByTestId(testID);
        const labelInputElement = getByTestId(label);
        expect(labelInputElement.props.animatedStyle.value).toEqual(
            expect.objectContaining(HelperStyle.fs_2),
        );
        expect(inputElement.props.value).toBe(value);
    });

    test('Debería estar en estado deshabilitado y tener estilos deshabilitado', () => {
        const { label, value, testID, onChangeText, disabled } = props;
        const Styles = buildStyles({
            maxHeight: inputDefaultProps.maxHeight,
            HelperStyle,
            isDisabled: disabled,
        });
        const { getByTestId } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                disabled={disabled}
            />,
        );
        const inputElement = getByTestId(testID);
        expect(Object.assign(...inputElement.props.style.flat(1))).toEqual(
            expect.objectContaining(HelperStyle.o_40),
        );
        expect(Styles.disabledMask).toEqual(
            expect.objectContaining(HelperStyle.o_40),
        );
        expect(inputElement.props.disabled).toBeTruthy();
    });

    test('Debería estar en estado cargado', () => {
        const { label, value, testID, onChangeText } = props;
        const { getByTestId, getByA11yLabel } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                loading
            />,
        );
        const inputElement = getByTestId(testID);
        const loadingElement = getByA11yLabel(
            INPUT_STR.InputLoading.accessibilityLabel,
        );
        expect(inputElement.props.disabled).toBeTruthy();
        expect(loadingElement).toBeDefined();
    });

    test('Debería renderizar input con prefijo y subfijo', () => {
        const { label, value, testID, onChangeText, renderLeft, renderRight } =
            props;
        const { getByText } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                renderLeft={renderLeft}
                renderRight={renderRight}
            />,
        );
        const leftElement = getByText(textLeft);
        const rightElement = getByText(textRight);
        expect(leftElement).toBeDefined();
        expect(rightElement).toBeDefined();
    });

    test('Debería renderizar input con componentes en lado izquierdo y derecho', () => {
        const { label, value, testID, onChangeText, renderLeft, renderRight } =
            props;
        const { getByText } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                renderLeftSide={renderLeft}
                renderRightSide={renderRight}
            />,
        );
        const leftElement = getByText(textLeft);
        const rightElement = getByText(textRight);
        expect(leftElement).toBeDefined();
        expect(rightElement).toBeDefined();
    });

    test('Debería renderizar input con componente en lado derecho con Error y tener estilo para corregir el centrado del lado derecho', () => {
        const { label, value, testID, onChangeText, renderRight, helperText } =
            props;
        const Styles = buildStyles({ HelperStyle });
        const { getByText, getByTestId } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                renderRightSide={renderRight}
                helperText={helperText}
                error
            />,
        );
        const rightElement = getByText(textRight);
        const rightSideElement = getByTestId(INPUT_STR.testID.rightSide);
        expect(rightElement).toBeDefined();
        expect(rightSideElement.props.style).toEqual(
            expect.objectContaining(Styles.centerSideWithError),
        );
    });

    test('Debería estar en estado foco', () => {
        const { label, value, testID, onChangeText } = props;
        const { getByTestId } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                onFocus={mockOnFocus}
            />,
        );
        const inputElement = getByTestId(testID);
        const labelInputElement = getByTestId(label);
        expect(labelInputElement.props.animatedStyle.value).toEqual(
            expect.objectContaining(HelperStyle.fs_2),
        );
        fireEvent(inputElement, 'onFocus');
        expect(inputElement).toBeDefined();
        expect(mockOnFocus).toHaveBeenCalledTimes(1);
    });

    test('Debería invocar estado de foco desde el componente subfijo', () => {
        const { label, value, testID, onChangeText, renderRight } = props;
        const { getByTestId, getByText } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                onFocus={mockOnFocus}
                renderRight={renderRight}
            />,
        );
        const rightElement = getByText(textRight);
        const inputElement = getByTestId(testID);
        const labelInputElement = getByTestId(label);
        fireEvent.press(rightElement);
        expect(labelInputElement.props.animatedStyle.value).toEqual(
            expect.objectContaining(HelperStyle.fs_2),
        );
        expect(inputElement).toBeDefined();
        expect(mockOnFocus).toHaveBeenCalledTimes(1);
    });

    test('Debería salir de foco', () => {
        const { label, testID, onChangeText } = props;
        const { getByTestId } = render(
            <Input
                testID={testID}
                label={label}
                onChangeText={onChangeText}
                onBlur={mockOnBlur}
            />,
        );
        const inputElement = getByTestId(testID);
        const labelInputElement = getByTestId(label);
        expect(labelInputElement.props.animatedStyle.value).toEqual(
            expect.objectContaining(HelperStyle.fs_3),
        );
        fireEvent(inputElement, 'onFocus');
        fireEvent(inputElement, 'onBlur');
        expect(inputElement).toBeDefined();
        expect(mockOnBlur).toHaveBeenCalledTimes(1);
    });

    test('Debería mostrar mensaje de ayuda', () => {
        const { label, testID, onChangeText, helperText, value } = props;
        const { getByText } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                onBlur={mockOnBlur}
                helperText={helperText}
            />,
        );
        expect(getByText(helperText)).toBeDefined();
    });

    test('Debería estar en estado de error y mostrar mensaje de error', () => {
        const { label, testID, onChangeText, helperText, value } = props;
        const { getByText, getByTestId } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                onBlur={mockOnBlur}
                helperText={helperText}
                error
            />,
        );
        const inputElement = getByTestId(testID);
        const mensajeElemnt = getByText(helperText);
        expect(inputElement.props.error).toBeTruthy();
        expect(mensajeElemnt).toBeDefined();
        expect(Object.assign(...mensajeElemnt.props.style)).toEqual(
            expect.objectContaining(HelperStyle.danger),
        );
    });

    test('Debería estar en estado de exito (success)', () => {
        const { label, testID, onChangeText, helperText, value } = props;
        const { getByTestId } = render(
            <Input
                testID={testID}
                label={label}
                value={value}
                onChangeText={onChangeText}
                onBlur={mockOnBlur}
                helperText={helperText}
                success
                showStateIconRight
            />,
        );
        const inputElement = getByTestId(testID);
        const iconElement = getByTestId(INPUT_STR.success.label);
        expect(inputElement.props.success).toBeTruthy();
        expect(iconElement).toBeDefined();
    });

    test('Debería renderizar input tipo multiline', () => {
        const { label, testID, onChangeText, maxLength, value } = props;
        const { getByTestId, getByText } = render(
            <Input
                testID={testID}
                label={label}
                onChangeText={onChangeText}
                onBlur={mockOnBlur}
                multiline
                maxLength={maxLength}
                value={value}
            />,
        );
        const inputElement = getByTestId(testID);
        const counterText = `${value.length}/${maxLength}`;
        expect(getByText(counterText)).toBeDefined();
        expect(Object.assign(...inputElement.props.style)).toEqual(
            expect.objectContaining(HelperStyle.h_auto),
        );
    });
});
