import React, { memo } from 'react';
import PropTypes from 'prop-types';
import LinearGradient from 'react-native-linear-gradient';
import Ripple from 'react-native-material-ripple';
import { View } from 'react-native';
import { HelperStyle, HelperOptions } from '../../../index';
import Style from '../style';
import { buttonPropTypes, buttonDefaultProps } from '../type';

/**
 * Componente color del botÃ³n.
 *
 * @component
 */
const ButtonColor = ({
    activeButtonColor,
    activeButtonSize,
    block,
    children,
    circle,
    condicionesSNEI,
    durationAnimation,
    error,
    inverse,
    isDisabled,
    medium,
    neutral,
    onPress,
    primary,
    secondary,
    showLoading,
    small,
    smaller,
    tiny,
}) => {
    const start = { x: 0, y: 0 };
    const end = { x: 1, y: 1 };

    const getLinearGradientColor = () => {
        if ((primary && isDisabled) || (secondary && showLoading)) {
            return [
                HelperStyle.primary_lighter.color,
                HelperStyle.primary_lighter.color,
            ];
        }
        if (primary && showLoading) {
            return [
                HelperStyle.primary_light.color,
                HelperStyle.primary_light.color,
            ];
        }
        if (neutral && showLoading) {
            return [
                HelperStyle.gray_lighter.color,
                HelperStyle.gray_lighter.color,
            ];
        }
        if (error && showLoading) {
            return [
                HelperStyle.danger_lighter.color,
                HelperStyle.danger_lighter.color,
            ];
        }
        if (secondary || neutral || error) {
            return [HelperStyle.white.color, HelperStyle.white.color];
        }
        if (inverse) return ['transparent', 'transparent'];
        return [HelperStyle.primary_light.color, HelperStyle.primary.color];
    };
    const getHeightButton = () => {
        const heightButton = {
            default: Style.buttonHeightDefault,
            medium: Style.buttonHeightMedium,
            small: Style.buttonHeightSmall,
            smaller: Style.buttonHeightSmaller,
            tiny: Style.buttonHeightTiny,
        };
        return heightButton[activeButtonSize] || heightButton.default;
    };
    const getButtonPadding = () => {
        const buttonPadding = {
            default: Style.buttonDefaultPadding,
            medium: Style.buttonSmallPadding,
            small: Style.buttonSmallPadding,
            smaller: Style.buttonSmallerPadding,
            tiny: Style.buttonTinyPadding,
        };
        const circlePrimaryButtonPaddings = {
            big: Style.buttonIconBigPadding,
            default: Style.buttonIconDefaultPadding,
            medium: Style.buttonIconMediumPadding,
            small: Style.buttonIconSmallPadding,
            smaller: Style.buttonIconSmallerPadding,
            tiny: Style.buttonIconTinyPadding,
        };
        const circleButtonPaddings = {
            big: Style.buttonIconBigPaddingNoBorder,
            default: Style.buttonIconDefaultPaddingNoBorder,
            medium: Style.buttonIconMediumPaddingNoBorder,
            small: Style.buttonIconSmallPaddingNoBorder,
            smaller: Style.buttonIconSmallerPaddingNoBorder,
            tiny: Style.buttonIconTinyPaddingNoBorder,
        };
        if (circle) {
            if (!primary) {
                return (
                    circleButtonPaddings[activeButtonSize] ||
                    circleButtonPaddings.default
                );
            }
            return (
                circlePrimaryButtonPaddings[activeButtonSize] ||
                circlePrimaryButtonPaddings.default
            );
        }
        return buttonPadding[activeButtonSize] || buttonPadding.default;
    };
    const RippleOnPress = () => onPress && onPress();
    const getRippleEffectColor = () => {
        const rippleColors = {
            primary: HelperOptions.colors.primary_light,
            secondary: HelperOptions.colors.primary_lighter,
            neutral: HelperOptions.colors.gray_lighter,
            error: HelperOptions.colors.danger_lighter,
            inverse: HelperOptions.colors.white_transparent,
        };
        if (activeButtonColor) return rippleColors[activeButtonColor];
        return rippleColors.primary;
    };
    const buttonRippleEffect = () => (
        <Ripple
            onPress={RippleOnPress}
            rippleOpacity={1}
            disabled={isDisabled}
            rippleColor={getRippleEffectColor()}
            style={Style.rippleStyle}
            rippleDuration={durationAnimation}
            rippleContainerBorderRadius={57}
            rippleFades={false}
        >
            <View style={[Style.buttonContentIconText, getButtonPadding()]}>
                {children}
            </View>
        </Ripple>
    );

    const getBorderColor = () => {
        const borderColors = {
            secondary: HelperStyle.bc_primary_lighter,
            neutral: HelperStyle.bc_gray_lighter,
            error: HelperStyle.bc_danger_lighter,
            inverse: HelperStyle.bc_gray_lighter,
        };
        if (isDisabled && !primary) return HelperStyle.bc_gray_lighter;
        if (activeButtonColor) return borderColors[activeButtonColor];
        return null;
    };

    const isButtonWidthFluid =
        !block && (circle || small || smaller || medium || tiny);

    return (
        <LinearGradient
            start={start}
            end={end}
            colors={getLinearGradientColor()}
            style={[
                Style.linearGradient,
                condicionesSNEI && HelperStyle.bw_2,
                getBorderColor(),
                getHeightButton(),
                isButtonWidthFluid && Style.buttonWidthFluid,
            ]}
        >
            {buttonRippleEffect()}
        </LinearGradient>
    );
};

ButtonColor.propTypes = {
    activeButtonColor: PropTypes.string,
    block: buttonPropTypes.block,
    children: buttonPropTypes.children,
    circle: buttonPropTypes.circle,
    condicionesSNEI: PropTypes.bool.isRequired,
    durationAnimation: PropTypes.number.isRequired,
    error: buttonPropTypes.error,
    inverse: buttonPropTypes.inverse,
    isDisabled: PropTypes.bool.isRequired,
    neutral: buttonPropTypes.neutral,
    onPress: buttonPropTypes.onPress,
    primary: buttonPropTypes.primary,
    secondary: buttonPropTypes.secondary,
    showLoading: PropTypes.bool.isRequired,
    small: buttonPropTypes.small,
    smaller: buttonPropTypes.smaller,
    activeButtonSize: PropTypes.string,
    medium: buttonPropTypes.medium,
    tiny: buttonPropTypes.tiny,
};
ButtonColor.defaultProps = {
    activeButtonColor: null,
    block: buttonDefaultProps.block,
    children: buttonDefaultProps.children,
    circle: buttonDefaultProps.circle,
    error: buttonDefaultProps.error,
    inverse: buttonDefaultProps.inverse,
    neutral: buttonDefaultProps.neutral,
    onPress: buttonDefaultProps.onPress,
    primary: buttonDefaultProps.primary,
    secondary: buttonDefaultProps.secondary,
    small: buttonDefaultProps.small,
    smaller: buttonDefaultProps.smaller,
    activeButtonSize: null,
    medium: buttonDefaultProps.medium,
    tiny: buttonDefaultProps.tiny,
};

export default memo(ButtonColor);
