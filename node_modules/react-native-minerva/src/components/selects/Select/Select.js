import React, { Fragment } from 'react';
import PropTypes from 'prop-types';
import { get, isObject, toString, isArray } from 'lodash';
import {
    TouchableOpacity,
    SafeAreaView,
    FlatList,
    SectionList,
} from 'react-native';
import { HeaderBackButton } from '@react-navigation/elements';
import Modal from 'react-native-modal';
import {
    Icon,
    HelperStyle,
    Highlighter,
    View,
    Header,
    Left,
    Body,
    Right,
    InputSearch,
    H4,
    Text,
    ListItem,
    Validate,
} from '../../../index';
import SelectInput from '../components/SelectInput';
import { selectPropTypes, selectDefaultProps } from '../type';
import SelectInputMultiline from './components/SelectInputMultiline';
import useSelect from './hook/useSelect';
import utils from './utils';
import SELECT_STR from '../constants/SelectStr';

/**
 * Componente formulario para seleccionar un valor de un conjunto de opciones.
 * Apariencia no nativa. Extiende de <Input /> y <Modal />.
 *
 * @component
 */
const Select = (props) => {
    const {
        items,
        onValueChange,
        selectedValue,
        placeholder,
        label,
        inputSearch,
        renderItem,
        contentContainerStyle,
        accessible,
        accessibilityLabel,
        accessibilityHint,
        testID,
        inverse,
        listEmptyComponent,
        styleContainer,
        disabled,
        multiline,
        controlModal,
        onPressSelect,
        section,
        renderSection,
        disabledAutoClose,
        ...inputProps
    } = props;
    const {
        isVisibleModal,
        setIsVisibleModal,
        selectItem,
        openModal,
        closeModal,
    } = useSelect({
        onValueChange,
        onPressSelect,
        inputSearch,
        controlModal,
        disabledAutoClose,
    });

    const keyExtractor = (item, index) => index.toString();

    const selected = utils.getSelected(items, selectedValue);

    const renderItemsSelect = (item, isSelected, index = 0) => {
        const key = `item-${index}`;
        const isHighlighter = isObject(inputSearch);
        const { label: itemLabel, value, style, ...textProps } = item;
        const HighlighterProps = {
            searchWords: [inputSearch?.value],
            key: value,
        };
        const defaultTextProps = {
            ...textProps,
            style: [
                HelperStyle.fs_3,
                HelperStyle.mb_0,
                Validate.style(isSelected, HelperStyle.primary),
                style,
                Validate.style(disabled, HelperStyle.gray_lighter),
            ],
        };
        const defaultHighlighterProps = {
            ...defaultTextProps,
            ...HighlighterProps,
        };
        const textValue = isObject(item) ? itemLabel : item;
        if (isHighlighter) {
            return (
                <Fragment key={key}>
                    <Highlighter
                        textToHighlight={textValue}
                        {...defaultHighlighterProps}
                    />
                </Fragment>
            );
        }
        return (
            <Text key={key} {...defaultTextProps}>
                {textValue}
            </Text>
        );
    };

    const handlerRenderItemsSelect = (itemSelected, isSelected, parenIndex) => {
        if (isArray(itemSelected?.label)) {
            return itemSelected?.label.map((item, index) =>
                renderItemsSelect(item, isSelected, `${parenIndex}-${index}`),
            );
        }
        return renderItemsSelect(itemSelected?.label, isSelected);
    };

    const handlerRenderSection = ({ section: sectionItem }) => {
        const { title } = sectionItem;
        if (renderSection) {
            return renderSection(title);
        }
        return <Text style={HelperStyle.ma_4}>{title}</Text>;
    };
    const handlerRenderItem = ({ item, index }) => {
        const { value } = item;
        const isSelected = toString(selectedValue) === toString(value);
        if (renderItem) {
            return (
                <TouchableOpacity
                    onPress={selectItem({ item, index })}
                    accessible={false}
                >
                    <View pointerEvents="none">
                        {renderItem(item, index, isSelected)}
                    </View>
                </TouchableOpacity>
            );
        }
        return (
            <ListItem
                selected={isSelected}
                onPress={selectItem({ item, index })}
                accessible={false}
            >
                <Body>{handlerRenderItemsSelect(item, isSelected, index)}</Body>
                {isSelected && (
                    <Right>
                        <Icon
                            type="Ionicons"
                            style={HelperStyle.primary}
                            name="checkmark"
                        />
                    </Right>
                )}
            </ListItem>
        );
    };

    const renderSelect = () => {
        if (multiline) {
            return (
                <SelectInputMultiline
                    error={inputProps?.error}
                    helperText={inputProps?.helperText}
                    disabled={disabled}
                    style={inputProps?.style}
                    label={label}
                    itemSelected={selected}
                />
            );
        }
        return (
            <SelectInput
                placeholder={placeholder}
                label={label}
                selectedValue={selectedValue}
                items={utils.getFlattenedItems(section, items)}
                accessible={accessible}
                accessibilityLabel={accessibilityLabel}
                accessibilityHint={accessibilityHint}
                testID={testID}
                inverse={inverse}
                disabled={disabled}
                {...inputProps}
            />
        );
    };

    return (
        <View style={styleContainer}>
            <TouchableOpacity
                onPress={openModal}
                accessible={false}
                disabled={disabled}
            >
                {renderSelect()}
            </TouchableOpacity>
            <Modal
                visible={isVisibleModal}
                animationType="slide"
                setVisible={setIsVisibleModal}
                onBackButtonPress={closeModal}
                style={[
                    HelperStyle.jc_fe,
                    HelperStyle.bg_white,
                    HelperStyle.ma_0,
                ]}
            >
                <Header
                    style={[
                        HelperStyle.shadow_header,
                        HelperStyle.pl_0,
                        HelperStyle.pr_0,
                        HelperStyle.mt_0,
                    ]}
                >
                    <Left>
                        <HeaderBackButton
                            labelVisible={false}
                            tintColor={HelperStyle.gray.color}
                            onPress={closeModal}
                        />
                    </Left>
                    <Body style={HelperStyle.flx_3}>
                        <H4 headerTitle style={HelperStyle.ta_c}>
                            {utils.getHeaderTitle(placeholder, label)}
                        </H4>
                    </Body>
                    <Right />
                </Header>
                {isObject(inputSearch) && (
                    <InputSearch
                        placeholder={SELECT_STR.buscar}
                        autoCorrect={false}
                        autoCapitalize="none"
                        {...inputSearch}
                        style={[
                            HelperStyle.pa_4,
                            get(inputSearch, 'style', null),
                        ]}
                    />
                )}
                <SafeAreaView style={HelperStyle.flx_i}>
                    {section ? (
                        <SectionList
                            sections={items}
                            keyExtractor={keyExtractor}
                            renderItem={handlerRenderItem}
                            style={[
                                HelperStyle.bg_brand_background,
                                HelperStyle.flx_i,
                            ]}
                            renderSectionHeader={handlerRenderSection}
                            contentContainerStyle={contentContainerStyle}
                            keyboardShouldPersistTaps="handled"
                            ListEmptyComponent={listEmptyComponent}
                            stickySectionHeadersEnabled={false} // Necesario para evitar que la primera seccion se quede fija. Solo pasa en IOS porque esta definido como standard.
                        />
                    ) : (
                        <FlatList
                            data={items}
                            renderItem={handlerRenderItem}
                            keyExtractor={keyExtractor}
                            style={[
                                HelperStyle.bg_brand_background,
                                HelperStyle.flx_i,
                            ]}
                            contentContainerStyle={contentContainerStyle}
                            keyboardShouldPersistTaps="handled"
                            ListEmptyComponent={listEmptyComponent}
                        />
                    )}
                </SafeAreaView>
            </Modal>
        </View>
    );
};

Select.propTypes = {
    ...selectPropTypes,
    /**
     * Estilos para el flatlist.
     */
    contentContainerStyle: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.array,
    ]),
    /**
     * Objecto para configurar el componente <InputSearch />.
     */
    inputSearch: PropTypes.oneOfType([
        PropTypes.bool,
        PropTypes.objectOf(PropTypes.any),
    ]),
    /**
     * Función que renderiza por cada elemento de data.
     */
    renderItem: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
    /**
     * Componente que se renderiza cuando la lista esta vacía.
     */
    listEmptyComponent: PropTypes.oneOfType([
        PropTypes.element,
        PropTypes.func,
    ]),
    /**
     * Boleano para campo de tipo multilineas.
     */
    multiline: PropTypes.bool,
    /**
     * Si esta definido devuelve una función con los parametros { open: openModal, close: closeModal }.
     */
    controlModal: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
    /**
     * Función que se invoca cuando se selecciona el Select.
     */
    onPressSelect: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
    /**
     * Boleano para admitir secciones.
     */
    section: PropTypes.bool,
    /**
     * Función que renderiza secciones.
     */
    renderSection: PropTypes.oneOfType([PropTypes.bool, PropTypes.func]),
};
Select.defaultProps = {
    ...selectDefaultProps,
    contentContainerStyle: {},
    inputSearch: false,
    renderItem: false,
    listEmptyComponent: null,
    multiline: false,
    controlModal: false,
    onPressSelect: false,
    section: false,
    renderSection: false,
};

export default Select;
