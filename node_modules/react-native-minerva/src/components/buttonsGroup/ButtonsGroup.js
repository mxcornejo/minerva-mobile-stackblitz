import React, { memo } from 'react';
import { isObject, isArray } from 'lodash';
import { View, Text, HelperStyle, Button, Validate } from '../../index';
import { propTypes, defaultProps } from './types';

/**
 * Componente para renderizar listado de <Button />.
 *
 * @component
 */
const ButtonsGroup = (props) => {
    const {
        items,
        horizontal,
        style,
        styleText,
        styleItems,
        small,
        disabled,
        loading,
        inline,
        block,
    } = props;

    const colors = ['primary', 'secondary', 'neutral', 'error', 'inverse'];

    /**
     * Retorna las concidencias.
     *
     * @param {object} options - Objeto.
     * @param {object} options.object - El objecto a filtrar.
     * @param {Array} options.filter - Las claves a filtrar del objecto.
     */
    const filtered = ({ object, filter }) => {
        if (isObject(object) && isArray(filter)) {
            return Object.keys(object)
                .filter((key) => filter.includes(key))
                .reduce((obj, key) => ({ ...obj, [key]: object[key] }), false);
        }
        return false;
    };

    /**
     * Retorna true si encuentra una clave en el objecto.
     *
     * @param {object} options - Objeto.
     * @param {object} options.object - El objecto a filtrar.
     * @param {Array} options.find - Las claves a buscar.
     */
    const hasProperties = ({ object, find }) => {
        if (isObject(object) && isArray(find)) {
            return (
                typeof find.find((i) =>
                    Object.prototype.hasOwnProperty.call(object, i),
                ) === 'string'
            );
        }
        return false;
    };

    /**
     * Determina el color del button.
     * SÃ­ item.props tiene un color lo define con este si no toma el color que venga desde las props.
     *
     * @param {object} item - El objecto de buttons.
     */
    const getButtonColor = (item) => {
        // Retornar color desde el item.props si existe
        if (hasProperties({ object: item?.props, find: colors })) {
            return filtered({ object: item?.props, filter: colors });
        }
        // Si no retornar color desde las props si existe
        return filtered({ object: props, filter: colors });
    };

    const getKey = (item, index) => `${index}-${item.title}`;

    const renderButton = (item, index, styleButtonType) => (
        <Button
            key={!inline && getKey(item, index)}
            accessibilityLabel={Validate.safeLabel(
                item?.props?.accessibilityLabel,
                item.title,
            )}
            accessibilityHint={Validate.safeLabel(
                item?.props?.accessibilityHint,
            )}
            testID={Validate.safeLabel(item?.props?.testID, item.title)}
            small={small}
            disabled={disabled}
            loading={loading}
            block={block}
            {...item.props}
            {...getButtonColor(item)}
            style={[
                horizontal && HelperStyle.flx_i,
                styleButtonType,
                styleItems,
            ]}
        >
            <Text
                numberOfLines={1}
                ellipsizeMode="tail"
                style={[HelperStyle.tt_u, styleText]}
            >
                {item.title}
            </Text>
        </Button>
    );

    /**
     * Determina si es un numero par.
     *
     * @param {number} index - Numero a evaluar.
     */
    const isEven = (index) => index % 2 === 0;

    /**
     * Determina si el Button debe tener padding bottom:
     * No debe tener padding bottom los Button de la ultima fila.
     *
     * @param {number} index - Indice del button en el arreglo de items.
     */
    const getSpacingBottom = (index) => {
        const itemsSize = items.length;
        const lastItem = index === itemsSize - 1;
        const secondToLast = index === itemsSize - 2;
        const lastItemsInRow =
            (isEven(itemsSize) && (lastItem || secondToLast)) ||
            (!isEven(itemsSize) && lastItem);

        return itemsSize > 2 && !lastItemsInRow && HelperStyle.mb_4;
    };

    const renderButtonType = (item, index = 0, lastItem = 0) => {
        const styleVertical = lastItem !== index && HelperStyle.mb_4;
        const styleHorizontal = {
            ...(lastItem !== index && HelperStyle.mr_4),
            ...HelperStyle.flx_i,
        };
        const styleInline = [
            HelperStyle.w_50,
            isEven(index) ? HelperStyle.pr_2 : HelperStyle.pl_2,
            getSpacingBottom(index),
        ];
        if (inline) {
            return (
                <View style={styleInline} key={getKey(item, index)}>
                    {renderButton(item, index)}
                </View>
            );
        }
        if (horizontal) {
            return renderButton(item, index, styleHorizontal);
        }
        return renderButton(item, index, styleVertical);
    };

    const mapRenderButtonType = (item, i) =>
        renderButtonType(item, i, items.length - 1);

    const renderItems = () =>
        items &&
        (isArray(items)
            ? items.map(mapRenderButtonType)
            : renderButtonType(items));

    return (
        <View
            style={[
                (horizontal || inline) && HelperStyle.flx_row,
                inline && HelperStyle.flx_wrap,
                style,
            ]}
        >
            {renderItems()}
        </View>
    );
};

ButtonsGroup.propTypes = {
    items: propTypes.items,
    horizontal: propTypes.horizontal,
    small: propTypes.small,
    style: propTypes.style,
    styleText: propTypes.styleText,
    styleItems: propTypes.styleItems,
    disabled: propTypes.disabled,
    loading: propTypes.loading,
    inline: propTypes.inline,
    block: propTypes.block,
};
ButtonsGroup.defaultProps = {
    items: defaultProps.items,
    horizontal: defaultProps.horizontal,
    small: defaultProps.small,
    style: defaultProps.style,
    styleText: defaultProps.styleText,
    styleItems: defaultProps.styleItems,
    disabled: defaultProps.disabled,
    loading: defaultProps.loading,
    inline: defaultProps.inline,
    block: defaultProps.block,
};

export default memo(ButtonsGroup);
