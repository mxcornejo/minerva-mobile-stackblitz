import React, { memo, useEffect } from 'react';
import { View } from 'native-base';
import { isArray } from 'lodash';
import PropTypes from 'prop-types';
import Images from 'bch-assets';
import Animated, {
    useSharedValue,
    useAnimatedStyle,
    interpolate,
    useDerivedValue,
    withTiming,
    interpolateColor,
    runOnJS,
} from 'react-native-reanimated';
import { StatusBar, ImageBackground } from 'react-native';
import { dimensions, HelperStyle } from '../../index';
import Style from './style';

const {
    bg: { waves },
} = Images;

/**
 * Componente de animación de entrada ripple.
 * El componente parte con un punto de 10x10  y este crece hasta cubrir toda la pantalla.
 *
 * @component
 */
const LoadingScreenBCH = ({
    children,
    circle,
    onEndAnimationEnd,
    onStartAnimationEnd,
    startEndAnimation,
    colorBackground,
    testID,
}) => {
    const animacionScale = useSharedValue(0);
    const animacionRadius = useSharedValue(0);
    const animacionBackground = useSharedValue(0);
    const duration = 1000;

    useEffect(() => {
        const callBackOnAnimacionScale = () => {
            if (onStartAnimationEnd) onStartAnimationEnd();
        };
        const startEntryAnimation = () => {
            animacionScale.value = withTiming(
                1,
                { duration },
                runOnJS(callBackOnAnimacionScale)(),
            );
            animacionRadius.value = withTiming(1, { duration });
        };
        startEntryAnimation();
    });

    useEffect(() => {
        const callBackOnAnimacionBackground = () => {
            if (onEndAnimationEnd) onEndAnimationEnd();
        };
        const handlerStartEndAnimation = () => {
            animacionBackground.value = withTiming(
                1,
                { duration: duration / 2.5 },
                runOnJS(callBackOnAnimacionBackground)(),
            );
        };
        handlerStartEndAnimation();
    }, [startEndAnimation]);

    const getOutputRangeInterpolateBackground = () => {
        let defaultoutputRange = [
            HelperStyle.primary.color,
            HelperStyle.brand.color,
        ];
        if (colorBackground) {
            defaultoutputRange = isArray(colorBackground)
                ? colorBackground
                : [colorBackground, colorBackground];
        }
        return defaultoutputRange;
    };

    const outputRangeInterpolateBackground =
        getOutputRangeInterpolateBackground();

    const interpolateBackground = useDerivedValue(() =>
        interpolateColor(
            animacionBackground.value,
            [0, 1],
            outputRangeInterpolateBackground,
        ),
    );

    const interpolateScale = useDerivedValue(() =>
        interpolate(
            animacionScale.value,
            [0, 1],
            [0, (dimensions.fullHeight * 2) / 5],
        ),
    );

    const interpolateRadius = useDerivedValue(() =>
        interpolate(
            animacionRadius.value,
            [0, 1],
            [dimensions.fullHeight / 2, 0],
        ),
    );

    const styleAnimacionRipple = useAnimatedStyle(() => ({
        backgroundColor: interpolateBackground.value,
        transform: [{ scale: interpolateScale.value }],
    }));

    const styleAnimacionRippleCircle = useAnimatedStyle(() => ({
        borderRadius: interpolateRadius.value,
    }));

    const renderRipleAnimation = () => (
        <Animated.View
            testID={testID}
            style={[
                styleAnimacionRipple,
                Style.ripple,
                circle ? Style.rippleCircle : Style.rippleSquare,
                circle ? styleAnimacionRippleCircle : null,
            ]}
        />
    );

    return (
        <View style={HelperStyle.flx_i}>
            <ImageBackground
                source={waves}
                style={Style.imageBackground}
                imageStyle={Style.imageStyle}
            />
            <StatusBar barStyle="light-content" />
            {renderRipleAnimation()}
            <View style={Style.containerLoading}>{children}</View>
        </View>
    );
};

LoadingScreenBCH.propTypes = {
    /**
     * Componente a renderizar.
     */
    children: PropTypes.oneOfType([
        PropTypes.arrayOf(PropTypes.node),
        PropTypes.node,
        PropTypes.bool,
    ]),
    /**
     * Boleano para definir forma circular al punto de partida de la animación.
     */
    circle: PropTypes.bool,
    /**
     * Función que se invoca cuando la animación de salida termina.
     */
    onEndAnimationEnd: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
    /**
     * Función que se invoca cuando la animación de salida empieza.
     */
    onStartAnimationEnd: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
    /**
     * Función que se invoca cuando la animación de entrada empieza.
     */
    startEndAnimation: PropTypes.bool,
    /**
     * Color del ripple.
     */
    colorBackground: PropTypes.oneOfType([
        PropTypes.arrayOf(PropTypes.string),
        PropTypes.string,
    ]),
    /**
     * Identificador para pruebas.
     */
    testID: PropTypes.string,
};
LoadingScreenBCH.defaultProps = {
    children: false,
    circle: false,
    onEndAnimationEnd: false,
    onStartAnimationEnd: false,
    startEndAnimation: false,
    colorBackground: '',
    testID: '',
};

export default memo(LoadingScreenBCH);
