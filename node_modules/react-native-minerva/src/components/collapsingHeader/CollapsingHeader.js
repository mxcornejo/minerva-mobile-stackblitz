/* eslint-disable react-hooks/rules-of-hooks */
import React, { memo, useState, useRef } from 'react';
import PropTypes from 'prop-types';
import Images from 'bch-assets';
import { merge } from 'lodash';
import { KeyboardAvoidingView } from 'react-native';
import Animated, {
    interpolate,
    useAnimatedStyle,
    useAnimatedScrollHandler,
    useSharedValue,
    Extrapolate,
    useDerivedValue,
} from 'react-native-reanimated';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import {
    dimensions,
    HelperStyle,
    getHeaderHeight,
    getHeaderStatusBarHeight,
    View,
    MainBackground,
    Spacing,
    Scale,
    Platform,
} from '../../index';
import buildStyle from './style';
import { DEFAULT_TYPES, TYPES } from '../../constants/propTypes';

/**
 * Componente encabezado colapsable con scroll.
 *
 * @component
 */
const CollapsingHeader = (props) => {
    const ref = useRef(null);
    const {
        bounces,
        children,
        contentContainerBodyStyle,
        contentContainerHeaderStyle,
        contentContainerStyle,
        mainBackground,
        maxHeight,
        onMomentumScrollEnd,
        onScrollEndDrag,
        overlapping,
        refreshControl,
        renderForeground,
        renderHeaderFixedForeground,
        showsVerticalScrollIndicator,
    } = props;
    const {
        bg: { waves },
    } = Images;
    const insets = useSafeAreaInsets();
    const headerHeight = Platform.android
        ? getHeaderStatusBarHeight
        : getHeaderHeight + insets.top;
    const heightCircle = overlapping ? Scale(72) : Spacing.spacer_6;
    const scrollY = useSharedValue(0);
    const [stateMaxHeight, setStateMaxHeight] = useState(maxHeight);
    const scrollHandler = useAnimatedScrollHandler((event) => {
        scrollY.value = event.contentOffset.y;
    });
    const minHeight = headerHeight;
    const Styles = buildStyle({ minHeight, heightCircle });
    const findDimesions = (layout) => {
        const { height } = layout;
        setStateMaxHeight(height);
    };
    const handlerOnLayout = (event) => findDimesions(event.nativeEvent.layout);

    const handlerRenderHeaderFixedForeground = () => {
        const start = stateMaxHeight - headerHeight;
        const end = start + 3;
        const inputRange = [start, end];
        const interpolateHeaderPositionY = useDerivedValue(() =>
            interpolate(
                scrollY.value,
                inputRange,
                [-headerHeight, 0],
                Extrapolate.CLAMP,
            ),
        );
        const translateY = useAnimatedStyle(() => ({
            transform: [{ translateY: interpolateHeaderPositionY.value }],
        }));
        const fixedHeader = {
            position: 'absolute',
            width: '100%',
            zIndex: 9999,
            height: headerHeight,
            transform: [{ translateY: interpolateHeaderPositionY }],
        };
        const MainBackgroundProps = {
            imageBackground: {
                source: waves,
                style: Styles.imageBackgroundHeaderSmall,
                imageStyle: Styles.imageStyle,
            },
            linearGradient: {
                end: { x: 1, y: 0 },
                style: Styles.headerFixedForeground,
            },
        };

        if (typeof mainBackground === 'object') {
            merge(MainBackgroundProps, mainBackground);
        }

        return (
            <Animated.View style={[fixedHeader, translateY]}>
                <MainBackground {...MainBackgroundProps} reanimated>
                    {renderHeaderFixedForeground()}
                </MainBackground>
            </Animated.View>
        );
    };

    const handlerRenderForeground = () => {
        const start = 0;
        const end = stateMaxHeight - heightCircle;
        const inputRange = [start, end];
        const interpolateBouncesHeaderPositionY = useDerivedValue(() =>
            interpolate(
                scrollY.value,
                [-100000, 0],
                [-100000, 0],
                Extrapolate.CLAMP,
            ),
        );
        const bouncesTranslateY = useAnimatedStyle(() => ({
            transform: [
                { translateY: interpolateBouncesHeaderPositionY.value },
            ],
        }));
        const interpolateBorderRadius = useDerivedValue(() =>
            interpolate(scrollY.value, inputRange, [
                dimensions.fullWidth / 2,
                0,
            ]),
        );
        const interpolateContentStyleEnd = overlapping ? -heightCircle : 0;
        const interpolateContentStyle = useDerivedValue(() =>
            interpolate(
                scrollY.value,
                inputRange,
                [0, interpolateContentStyleEnd],
                Extrapolate.CLAMP,
            ),
        );
        const translateYstyleAnimatedView = useAnimatedStyle(() => ({
            transform: [{ translateY: interpolateContentStyle.value }],
        }));
        const styleAnimatedView = useAnimatedStyle(() => ({
            borderBottomLeftRadius: interpolateBorderRadius.value,
            borderBottomRightRadius: interpolateBorderRadius.value,
            transform: [
                { scaleX: 2 },
                { translateY: interpolateContentStyle.value },
            ],
        }));
        const MainBackgroundProps = {
            styleAnimatedView,
            imageBackground: {
                source: waves,
                style: Styles.imageBackgroundHeaderDefault,
                imageStyle: Styles.imageStyle,
            },
        };

        if (typeof mainBackground === 'object') {
            merge(MainBackgroundProps, mainBackground);
        }

        return (
            <Animated.View
                style={[
                    contentContainerHeaderStyle,
                    Styles.bounceStyle,
                    bouncesTranslateY,
                ]}
                onLayout={handlerOnLayout}
            >
                <MainBackground {...MainBackgroundProps} reanimated>
                    <Animated.View
                        style={[
                            Styles.translateStyle,
                            translateYstyleAnimatedView,
                        ]}
                    >
                        {renderForeground && renderForeground()}
                    </Animated.View>
                </MainBackground>
            </Animated.View>
        );
    };

    const handlerChildren = () => {
        const containerChildrenStyle = overlapping ? Styles.overlapping : null;
        return (
            <View style={[contentContainerBodyStyle, containerChildrenStyle]}>
                {children}
            </View>
        );
    };

    const behavior = Platform.ios ? 'padding' : null;

    return (
        <KeyboardAvoidingView
            behavior={behavior}
            enabled
            style={HelperStyle.flx_i}
        >
            {renderHeaderFixedForeground &&
                handlerRenderHeaderFixedForeground()}
            <Animated.ScrollView
                bounces={bounces}
                ref={ref}
                keyboardShouldPersistTaps="handled"
                onScroll={scrollHandler}
                onScrollEndDrag={onScrollEndDrag}
                onMomentumScrollEnd={onMomentumScrollEnd}
                scrollEventThrottle={16}
                refreshControl={refreshControl}
                contentContainerStyle={contentContainerStyle}
                showsVerticalScrollIndicator={showsVerticalScrollIndicator}
            >
                {handlerRenderForeground()}
                {handlerChildren()}
            </Animated.ScrollView>
        </KeyboardAvoidingView>
    );
};

CollapsingHeader.propTypes = {
    /**
     * SOLO IOS: Boleano para agregar animación de rebote cuando llega al final del scroll.
     */
    bounces: PropTypes.bool,
    /**
     * Componente que se renderiza en contenido del scroll debajo del encabezado.
     */
    children: PropTypes.oneOfType([
        PropTypes.arrayOf(PropTypes.node),
        PropTypes.node,
        PropTypes.bool,
    ]),
    /**
     * Altura máxima del encabezado colapsable.
     */
    maxHeight: PropTypes.number,
    /**
     * Funcion que se llama cuando finaliza el desplazamiento del scroll.
     */
    onMomentumScrollEnd: PropTypes.func,
    /**
     * Funcion que se llama cuando el usuario deja de arrastrar la vista de desplazamiento.
     */
    onScrollEndDrag: PropTypes.func,
    /**
     * Renderiza componente RefreshControl para controlar el gesto de pull to refesh.
     */
    refreshControl: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
    /**
     * Componente que se renderiza en el encabezado.
     */
    renderForeground: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
    /**
     * Componente flotante que se renderiza en la parte superior cuando el encabezado de colapsa.
     */
    renderHeaderFixedForeground: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.bool,
    ]),
    /**
     * Boleano para indicarle al contenido (children) que se sobre ponga en el area circular inferior de la cabecera.
     */
    overlapping: PropTypes.bool,
    /**
     * Boleano para indicar si se muestra un indicador de desplazamiento vertical.
     */
    showsVerticalScrollIndicator: PropTypes.bool,
    /**
     * Propiedades para configurar el componente <MainBackground />.
     */
    mainBackground: PropTypes.oneOfType([PropTypes.object, PropTypes.bool]),
    /**
     * Estilos para el contenedor del scrollView.
     */
    contentContainerStyle: TYPES.style,
    /**
     * Estilos para el contenedor del area del body en el contenedor del scrollView.
     */
    contentContainerBodyStyle: TYPES.style,
    /**
     * Estilos para el contenedor del area del header en el contenedor del scrollView.
     */
    contentContainerHeaderStyle: TYPES.style,
};
CollapsingHeader.defaultProps = {
    bounces: false,
    children: false,
    maxHeight: Scale(200),
    onMomentumScrollEnd: DEFAULT_TYPES.func,
    onScrollEndDrag: DEFAULT_TYPES.func,
    refreshControl: false,
    renderForeground: false,
    renderHeaderFixedForeground: false,
    overlapping: true,
    showsVerticalScrollIndicator: true,
    mainBackground: false,
    contentContainerStyle: DEFAULT_TYPES.style,
    contentContainerBodyStyle: DEFAULT_TYPES.style,
    contentContainerHeaderStyle: DEFAULT_TYPES.style,
};

export default memo(CollapsingHeader);
