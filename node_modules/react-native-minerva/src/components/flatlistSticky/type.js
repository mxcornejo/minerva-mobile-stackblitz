import PropTypes from 'prop-types';

const propTypesFlatlistSticky = {
    /**
     * SOLO IOS: Boleano para agregar animación de rebote cuando llega al final del scroll.
     */
    bounces: PropTypes.bool,
    /**
     * Boleano para centrar verticalmente el contenido del <ScrollView />.
     */
    centerContent: PropTypes.bool,
    /**
     * Estilos del contenedor del flatlist.
     */
    contentContainerStyle: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.array,
    ]),
    /**
     * Arreglo de componentes a renderizar en la cabecera del listado.
     */
    dataListHeader: PropTypes.arrayOf(
        PropTypes.shape({
            component: PropTypes.func,
        }),
    ),
    /**
     * Boleano para definir estado de error.
     */
    error: PropTypes.bool,
    /**
     * Determina cuándo el teclado debe permanecer visible después de un toque.
     */
    keyboardShouldPersistTaps: PropTypes.oneOf(['never', 'always', 'handled']),
    /**
     * Distancia entre la parte superior de la pantalla del usuario y la vista nativa.
     */
    keyboardVerticalOffset: PropTypes.number,
    /**
     * Función que generar clave única por cada fila en la lista.
     */
    keyExtractor: PropTypes.func,
    /**
     * Componente que se renderiza cuando la lista esta vacía.
     */
    ListEmptyComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Componente que se renderiza cuando la lista esta en estado de error.
     */
    ListErrorComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Componente que se renderiza en la parte inferior de la lista.
     */
    ListFooterComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Componente que se renderiza en la parte superior de la lista.
     */
    ListHeaderComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Componente que se renderiza cuando la lista esta en estado loading.
     */
    ListLoadingComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Boleano para definir estado de loading.
     */
    loading: PropTypes.bool,
    /**
     * Renderiza componente RefreshControl para controlar el gesto de pull to refesh.
     */
    refreshControl: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Función que renderiza por cada elemento de data.
     */
    renderItem: PropTypes.func.isRequired,
    /**
     * Referencia.
     */
    scrollRef: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.string,
        PropTypes.shape({
            current: PropTypes.oneOfType([
                PropTypes.objectOf(PropTypes.any),
                PropTypes.string,
            ]),
        }),
    ]),
    /**
     * Arreglo con la data de los elementos del listado.
     */
    data: PropTypes.arrayOf(PropTypes.any),
    /**
     * Arreglo con los indices de los elementos del listado que seran flotantes.
     */
    stickyHeaderIndices: PropTypes.arrayOf(PropTypes.number),
};

const defaultPropsFlatlistSticky = {
    bounces: true,
    centerContent: false,
    contentContainerStyle: {},
    data: [],
    dataListHeader: [],
    error: false,
    keyboardShouldPersistTaps: 'never',
    keyboardVerticalOffset: 0,
    keyExtractor: null,
    ListEmptyComponent: null,
    ListErrorComponent: null,
    ListFooterComponent: null,
    ListHeaderComponent: null,
    ListLoadingComponent: null,
    loading: false,
    refreshControl: null,
    scrollRef: null,
    stickyHeaderIndices: [],
};

export { propTypesFlatlistSticky, defaultPropsFlatlistSticky };
