import React, { memo } from 'react';
import PropTypes from 'prop-types';
import { FlatList } from 'react-native';
import { transformData, handlerRenderItem } from './utils';

/**
 * Componente listado agrupado con elemento flotantes. Extiende de <Flatlist />.
 *
 * @component
 */
const SectionStickyList = ({
    bounces,
    centerContent,
    contentContainerStyle,
    dataListHeader,
    error,
    keyboardShouldPersistTaps,
    keyboardVerticalOffset,
    keyExtractor,
    ListEmptyComponent,
    ListErrorComponent,
    ListFooterComponent,
    ListHeaderComponent,
    ListLoadingComponent,
    loading,
    refreshControl,
    renderItem,
    renderSectionHeader,
    scrollRef,
    sections,
    stickyHeaderIndices,
}) => (
    <FlatList
        bounces={bounces}
        centerContent={centerContent}
        contentContainerStyle={contentContainerStyle}
        data={transformData({
            sections,
            dataListHeader,
            error,
            ListEmptyComponent,
            ListErrorComponent,
            ListLoadingComponent,
            loading,
        })}
        keyboardShouldPersistTaps={keyboardShouldPersistTaps}
        keyboardVerticalOffset={keyboardVerticalOffset}
        keyExtractor={keyExtractor}
        ListEmptyComponent={ListEmptyComponent}
        ListFooterComponent={ListFooterComponent}
        ListHeaderComponent={ListHeaderComponent}
        ref={scrollRef}
        refreshControl={refreshControl}
        renderItem={handlerRenderItem({
            renderItem,
            renderSectionHeader,
            sections,
        })}
        stickyHeaderIndices={stickyHeaderIndices}
    />
);

SectionStickyList.propTypes = {
    /**
     * SOLO IOS: Boleano para agregar animación de rebote cuando llega al final del scroll.
     */
    bounces: PropTypes.bool,
    /**
     * Boleano para centrar verticalmente el contenido del <ScrollView />.
     */
    centerContent: PropTypes.bool,
    /**
     * Estilos del contenedor del flatlist.
     */
    contentContainerStyle: PropTypes.oneOfType([
        PropTypes.object,
        PropTypes.array,
    ]),
    /**
     * Arreglo de componentes a renderizar en la cabecera del listado.
     */
    dataListHeader: PropTypes.arrayOf(PropTypes.object),
    /**
     * Determina cuándo el teclado debe permanecer visible después de un toque.
     */
    keyboardShouldPersistTaps: PropTypes.oneOf(['never', 'always', 'handled']),
    /**
     * Distancia entre la parte superior de la pantalla del usuario y la vista nativa.
     */
    keyboardVerticalOffset: PropTypes.number,
    /**
     * Función que generar clave única por cada fila en la lista.
     */
    keyExtractor: PropTypes.func,
    /**
     * Componente que se renderiza cuando la lista esta vacía.
     */
    ListEmptyComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Componente que se renderiza en la parte inferior de la lista.
     */
    ListFooterComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Componente que se renderiza en la parte superior de la lista.
     */
    ListHeaderComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Renderiza componente RefreshControl para controlar el gesto de pull to refesh.
     */
    refreshControl: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Función que renderiza por cada hijo del grupo de datos de sections.
     */
    renderItem: PropTypes.func.isRequired,
    /**
     * Función que renderiza por cada cabecera del grupo.
     */
    renderSectionHeader: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Referencia.
     */
    scrollRef: PropTypes.oneOfType([
        PropTypes.func,
        PropTypes.string,
        PropTypes.shape({
            current: PropTypes.oneOfType([
                PropTypes.objectOf(PropTypes.any),
                PropTypes.string,
            ]),
        }),
    ]),
    /**
     * Arreglo con la data de los elementos del listado agrupado.
     */
    sections: PropTypes.arrayOf(PropTypes.any),
    /**
     * Arreglo con los indices de los elementos del listado que seran flotantes.
     */
    stickyHeaderIndices: PropTypes.arrayOf(PropTypes.number),
    /**
     * Componente que se renderiza cuando la lista esta en estado de error.
     */
    ListErrorComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
    /**
     * Boleano para definir estado de error.
     */
    error: PropTypes.bool,
    /**
     * Boleano para definir estado de loading.
     */
    loading: PropTypes.bool,
    /**
     * Componente que se renderiza cuando la lista esta en estado loading.
     */
    ListLoadingComponent: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
};
SectionStickyList.defaultProps = {
    bounces: true,
    centerContent: false,
    contentContainerStyle: {},
    dataListHeader: [],
    error: false,
    keyboardShouldPersistTaps: 'never',
    keyboardVerticalOffset: 0,
    keyExtractor: null,
    ListEmptyComponent: null,
    ListErrorComponent: null,
    ListFooterComponent: null,
    ListHeaderComponent: null,
    ListLoadingComponent: null,
    loading: false,
    refreshControl: null,
    renderSectionHeader: null,
    scrollRef: null,
    sections: [],
    stickyHeaderIndices: [],
};

export default memo(SectionStickyList);
