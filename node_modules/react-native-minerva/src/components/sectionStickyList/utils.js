import { get } from 'lodash';
import { Validate } from '../../index';

const getHeaderSectionName = ({ sections }) => {
    let headerSectionName = '';
    if (sections[0]) {
        const { data, ...headerProperty } = sections[0];
        headerSectionName = Object.keys(headerProperty);
    }
    return headerSectionName;
};

const handlerRenderItem = (props) => (itemData) => {
    const { renderItem, renderSectionHeader, sections } = props;
    const { item, separators } = itemData;
    const headerSectionName = getHeaderSectionName({ sections });
    const isHeaderSection = get(item, headerSectionName, false);
    const isdataListHeader = get(item, 'component', false);
    const isCustomComponent = get(item, 'component', false);
    // Retorna los componentes en el objecto isdataListHeader en la cabecera
    if (isdataListHeader) {
        return Validate.render(item.component);
    }
    // Retorna las cabeceras
    if (isHeaderSection && renderSectionHeader) {
        const firsSectionHeader = sections[0][headerSectionName];
        const isFirstItem = item[headerSectionName] === firsSectionHeader;
        return renderSectionHeader({ section: item, isFirstItem });
    }

    // Retornar un custom componente
    if (isCustomComponent) {
        return Validate.render(item.component);
    }

    // Retorna los elementos de la lista
    const { data, indexGroup, section } = item;
    return renderItem({
        item: data,
        index: indexGroup,
        section,
        separators,
    });
};

const transformData = ({
    sections,
    dataListHeader,
    error,
    loading,
    ListLoadingComponent,
    ListErrorComponent,
    ListEmptyComponent,
}) => {
    let ungroupData = [];
    if (sections.length !== 0) {
        const indexed = sections.reduce(
            (acc, el) => ({
                ...acc,
                [el[getHeaderSectionName({ sections })]]: el,
            }),
            {},
        );
        // desagrupa los datos de sections
        ungroupData = sections.flatMap((item) => {
            const { data, ...parent } = item;
            const section = indexed[Object.values(parent)];
            const groupedData = data.map((v, i) => ({
                data: v,
                section,
                indexGroup: i,
            }));
            return [parent].concat(groupedData);
        });
    }

    // si loading esta definido solo envia componente loading a la data
    if (loading) ungroupData = [{ component: ListLoadingComponent }];

    // si error esta definido y loading es false solo envia componente error a la data
    if (!loading && error) ungroupData = [{ component: ListErrorComponent }];

    // si dataListHeader esta definido
    // Agrega en la primera posicion del arreglo los componentes en el objecto dataListHeader
    if (dataListHeader) {
        ungroupData.unshift(dataListHeader);
    }

    // Agrega posici√≥n vacia si sections no tiene datos y error y loading son false
    if (!error && !loading && sections.length === 0) {
        ungroupData.push({ component: ListEmptyComponent });
    }
    return ungroupData.flat();
};

export { handlerRenderItem, transformData };
