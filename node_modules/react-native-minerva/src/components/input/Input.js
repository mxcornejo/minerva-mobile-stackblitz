import React, { memo, useRef, useState, useEffect } from 'react';
import { TouchableWithoutFeedback, View } from 'react-native';
import { Input, Item } from 'native-base';
import Animated, {
    useSharedValue,
    interpolate,
    useDerivedValue,
    withTiming,
    useAnimatedStyle,
} from 'react-native-reanimated';
import { HelperStyle, Scale, Spacing, Validate, Text, Icon } from '../../index';
import buildStyles from './style';
import InputBorder from './components/InputBorder';
import { inputPropTypes, inputDefaultProps } from './type';
import InputBottomText from './components/InputBottomText';
import InputLoading from './components/InputLoading';
import INPUT_STR from './inputStr';

/**
 * Componente campo de texto.
 *
 * @component
 */
const InputBCH = (props) => {
    const {
        digiCard,
        disabled,
        error,
        helperText,
        inputRef,
        label,
        labelAccessibilityLabel,
        labeAccessibilityHint,
        labelTestID,
        large,
        number,
        onBlur,
        onFocus,
        pass,
        renderLeft,
        renderLeftSide,
        renderRight,
        renderRightSide,
        style,
        value,
        pointerEvents,
        isRenderRightVisible,
        inverse,
        select,
        testID,
        accessibilityLabel,
        accessibilityHint,
        disabledPadding,
        isOpenSelect,
        multiline,
        maxHeight,
        maxLength,
        loading,
        success,
        showStateIconRight,
    } = props;
    const isDisabled = loading || disabled;
    const Styles = buildStyles({ maxHeight, HelperStyle, isDisabled });
    const [isFocus, setIsFocus] = useState(false);
    const [inputHeight, setinputHeight] = useState(0);
    const floatUpPosition = -Scale(29);
    const getinitialState = (valueTrue, valueFalse) =>
        value ? valueTrue : valueFalse;
    const translateAnimation = useSharedValue(
        getinitialState(floatUpPosition, 0),
    );
    const toggleAnimation = useSharedValue(getinitialState(1, 0));
    const [borderWidth, setBorderWidth] = useState({ width: 0 });
    const defaultInputRef = useRef(null);
    const ref = inputRef || defaultInputRef;
    const duration = 150;
    const hasRenderSide = renderLeftSide || renderRightSide;

    const colorInverse = Validate.style(inverse, HelperStyle.white);

    const clearPadding = Validate.style(disabledPadding, Styles.clearPadding);

    const setFocus = () => ref.current._root.focus();

    const floatUp = () => {
        translateAnimation.value = withTiming(floatUpPosition, { duration });
        toggleAnimation.value = withTiming(1, { duration });
    };

    const floatBack = () => {
        translateAnimation.value = withTiming(0, { duration });
        toggleAnimation.value = withTiming(0, { duration });
    };

    const handlerOnFocus = () => {
        setIsFocus(true);
        floatUp();
        Validate.func(onFocus);
    };

    const handlerOnBlur = () => {
        setIsFocus(false);
        if (typeof value === 'undefined' || value === '') {
            floatBack();
        }
        Validate.func(onBlur);
    };

    useEffect(() => {
        if (value || isOpenSelect) {
            floatUp();
        } else if (!isFocus) {
            floatBack();
        }
    }, [value, isOpenSelect]);

    const interpolateScale = useDerivedValue(() =>
        interpolate(
            toggleAnimation.value,
            [0, 1],
            [Spacing.type_3, Spacing.type_2],
        ),
    );

    const containerLeftAnimatedStyle = useAnimatedStyle(() => ({
        opacity: toggleAnimation.value,
    }));

    const containerRightAnimatedStyle = useAnimatedStyle(() => ({
        opacity: toggleAnimation.value,
    }));

    const labelContainerAnimatedStyle = useAnimatedStyle(() => ({
        transform: [{ translateY: translateAnimation.value }],
    }));

    const labelAnimatedStyle = useAnimatedStyle(() => ({
        fontSize: interpolateScale.value,
    }));

    const isDisabledStyle = isDisabled && value;

    const handlerRenderLeft = () => {
        const containerLeftStyle = isDisabledStyle
            ? Styles.disabledMask
            : containerLeftAnimatedStyle;
        if (renderLeft) {
            return (
                <Animated.View style={containerLeftStyle}>
                    <TouchableWithoutFeedback
                        accessibilityRole="none"
                        onPress={setFocus}
                    >
                        <View style={Styles.contentLeft}>
                            {Validate.render(renderLeft)}
                        </View>
                    </TouchableWithoutFeedback>
                </Animated.View>
            );
        }
        return null;
    };

    const handlerRenderRight = () => {
        const containerLeftStyle = isDisabledStyle
            ? Styles.disabledMask
            : containerRightAnimatedStyle;
        if (loading) return <InputLoading inverse={inverse} />;
        if (renderRight) {
            return (
                <Animated.View
                    style={Validate.style(
                        !isRenderRightVisible,
                        containerLeftStyle,
                        Styles.disabledMask,
                    )}
                >
                    <TouchableWithoutFeedback
                        accessibilityRole="none"
                        onPress={setFocus}
                    >
                        <View style={Styles.contentRight}>
                            {Validate.render(renderRight)}
                        </View>
                    </TouchableWithoutFeedback>
                </Animated.View>
            );
        }
        if (success && showStateIconRight)
            return (
                <Icon
                    style={[HelperStyle.fs_3, HelperStyle.success]}
                    name={INPUT_STR.success.name}
                    accessibilityLabel={INPUT_STR.success.label}
                    accessibilityHint={INPUT_STR.success.hint}
                    testID={INPUT_STR.success.label}
                />
            );
        return null;
    };

    const findDimesions = (layout) => {
        const { width } = layout;
        setBorderWidth({ width });
    };

    const handlerOnLayout = (event) => findDimesions(event.nativeEvent.layout);

    const renderLabel = () => (
        <Animated.View
            pointerEvents="none"
            style={[
                Styles.LabelContainer,
                labelContainerAnimatedStyle,
                Styles.disabledMask,
            ]}
            onLayout={handlerOnLayout}
        >
            <Animated.Text
                style={Validate.truthyArray([
                    Styles.label,
                    HelperStyle.gray,
                    colorInverse,
                    Validate.style(isFocus, HelperStyle.fs_2),
                    Validate.style(isOpenSelect, HelperStyle.fs_2),
                    labelAnimatedStyle,
                ])}
                accessible
                accessibilityLabel={Validate.safeLabel(
                    labelAccessibilityLabel,
                    label,
                )}
                accessibilityHint={Validate.safeLabel(labeAccessibilityHint)}
                testID={Validate.safeLabel(labelTestID, label)}
            >
                {label}
            </Animated.Text>
        </Animated.View>
    );

    const inputValueContainer = () => {
        if (select) {
            return (
                <TouchableWithoutFeedback
                    onPress={handlerOnFocus}
                    accessible={false}
                >
                    <View
                        accessible={false}
                        style={[
                            Styles.inputHeightBase,
                            HelperStyle.flx_i,
                            HelperStyle.jc_c,
                            Styles.disabledMask,
                        ]}
                    >
                        <Text
                            testID={testID}
                            accessibilityLabel={accessibilityLabel}
                            accessibilityHint={accessibilityHint}
                            ellipsizeMode="tail"
                            numberOfLines={1}
                            style={[
                                HelperStyle.mb_0,
                                HelperStyle.gray_dark,
                                colorInverse,
                            ]}
                        >
                            {value}
                        </Text>
                    </View>
                </TouchableWithoutFeedback>
            );
        }
        return (
            <Input
                selectionColor={HelperStyle.gray_lighter.color}
                testID={testID}
                accessibilityLabel={accessibilityLabel}
                accessibilityHint={accessibilityHint}
                {...props}
                disabled={isDisabled}
                ref={ref}
                onFocus={handlerOnFocus}
                onBlur={handlerOnBlur}
                style={Validate.truthyArray([
                    HelperStyle.t_0,
                    Validate.style(multiline, Styles.inputMultiline),
                    Styles.disabledMask,
                ])}
            />
        );
    };
    const findDimesionsInput = (layout) => {
        const { height } = layout;
        setinputHeight(height);
    };
    const handlerOnLayoutInput = (event) =>
        multiline && findDimesionsInput(event.nativeEvent.layout);

    const renderInput = () => (
        <View
            pointerEvents={pointerEvents}
            style={Validate.truthyArray([
                Validate.style(!digiCard, HelperStyle.mb_4),
                Validate.style(hasRenderSide, HelperStyle.flx_i),
                HelperStyle.mt_2,
                style,
            ])}
        >
            <InputBorder
                disabled={isDisabled}
                error={error}
                success={success}
                value={value}
                inverse={inverse}
                borderWidth={borderWidth}
                isFocus={isFocus}
                isOpenSelect={isOpenSelect}
                inputHeight={inputHeight}
                multiline={multiline}
            />
            <Item
                regular
                error={error}
                disabled={isDisabled}
                inputFloatingLabel
                isFocus={isFocus}
                large={large}
                number={number}
                pass={pass}
                style={Validate.truthyArray([
                    HelperStyle.ml_0,
                    clearPadding,
                    Validate.style(multiline, Styles.itemMultiline),
                ])}
                inverse={inverse}
                accessible={false}
                onLayout={handlerOnLayoutInput}
            >
                {Validate.render(renderLabel, label)}
                {handlerRenderLeft()}
                {inputValueContainer()}
                {handlerRenderRight()}
            </Item>
            <InputBottomText
                maxLength={maxLength}
                digiCard={digiCard}
                multiline={multiline}
                value={value}
                error={error}
                inverse={inverse}
                helperText={helperText}
            />
        </View>
    );

    const handleRenderSide = (renderSide) =>
        renderSide && (
            <View
                style={Validate.style(
                    helperText && error,
                    Styles.centerSideWithError,
                    HelperStyle.mb_2,
                )}
                testID={
                    renderLeftSide
                        ? INPUT_STR.testID.leftSide
                        : INPUT_STR.testID.rightSide
                }
            >
                {Validate.render(renderSide)}
            </View>
        );

    const renderInputContent = () => {
        if (hasRenderSide) {
            return (
                <View style={[HelperStyle.flx_row, HelperStyle.ai_c]}>
                    {handleRenderSide(renderLeftSide)}
                    {renderInput()}
                    {handleRenderSide(renderRightSide)}
                </View>
            );
        }
        return renderInput();
    };

    return renderInputContent();
};

InputBCH.propTypes = {
    digiCard: inputPropTypes.digiCard,
    disabled: inputPropTypes.disabled,
    error: inputPropTypes.error,
    helperText: inputPropTypes.helperText,
    inputRef: inputPropTypes.inputRef,
    label: inputPropTypes.label,
    labelTestID: inputPropTypes.labelTestID,
    labelAccessibilityLabel: inputPropTypes.labelAccessibilityLabel,
    labeAccessibilityHint: inputPropTypes.labelAccessibilityHint,
    large: inputPropTypes.large,
    multiline: inputPropTypes.multiline,
    number: inputPropTypes.number,
    onBlur: inputPropTypes.onBlur,
    onFocus: inputPropTypes.onFocus,
    pass: inputPropTypes.pass,
    renderLeft: inputPropTypes.renderLeft,
    renderLeftSide: inputPropTypes.renderLeftSide,
    renderRight: inputPropTypes.renderRight,
    renderRightSide: inputPropTypes.renderRightSide,
    value: inputPropTypes.value,
    inverse: inputPropTypes.inverse,
    select: inputPropTypes.select,
    testID: inputPropTypes.testID,
    accessibilityLabel: inputPropTypes.accessibilityLabel,
    accessibilityHint: inputPropTypes.accessibilityHint,
    style: inputPropTypes.style,
    pointerEvents: inputPropTypes.pointerEvents,
    isRenderRightVisible: inputPropTypes.isRenderRightVisible,
    disabledPadding: inputPropTypes.disabledPadding,
    isOpenSelect: inputPropTypes.isOpenSelect,
    maxHeight: inputPropTypes.maxHeight,
    maxLength: inputPropTypes.maxLength,
    loading: inputPropTypes.loading,
    success: inputPropTypes.success,
    showStateIconRight: inputPropTypes.showStateIconRight,
};
InputBCH.defaultProps = {
    digiCard: inputDefaultProps.digiCard,
    disabled: inputDefaultProps.disabled,
    error: inputDefaultProps.error,
    helperText: inputDefaultProps.helperText,
    inputRef: inputDefaultProps.inputRef,
    label: inputDefaultProps.label,
    labelTestID: inputDefaultProps.labelTestID,
    labelAccessibilityLabel: inputDefaultProps.labelAccessibilityLabel,
    labeAccessibilityHint: inputDefaultProps.labelAccessibilityHint,
    large: inputDefaultProps.large,
    multiline: inputDefaultProps.multiline,
    number: inputDefaultProps.number,
    onBlur: inputDefaultProps.onBlur,
    onFocus: inputDefaultProps.onFocus,
    pass: inputDefaultProps.pass,
    renderLeft: inputDefaultProps.renderLeft,
    renderLeftSide: inputDefaultProps.renderLeftSide,
    renderRight: inputDefaultProps.renderRight,
    renderRightSide: inputDefaultProps.renderRightSide,
    value: inputDefaultProps.value,
    inverse: inputDefaultProps.inverse,
    select: inputDefaultProps.select,
    testID: inputDefaultProps.testID,
    accessibilityLabel: inputDefaultProps.accessibilityLabel,
    accessibilityHint: inputDefaultProps.accessibilityHint,
    style: inputDefaultProps.style,
    pointerEvents: inputDefaultProps.pointerEvents,
    isRenderRightVisible: inputDefaultProps.isRenderRightVisible,
    disabledPadding: inputDefaultProps.disabledPadding,
    isOpenSelect: inputDefaultProps.isOpenSelect,
    maxHeight: inputDefaultProps.maxHeight,
    maxLength: inputDefaultProps.maxLength,
    loading: inputDefaultProps.loading,
    success: inputDefaultProps.success,
    showStateIconRight: inputDefaultProps.showStateIconRight,
};

export default memo(InputBCH);
