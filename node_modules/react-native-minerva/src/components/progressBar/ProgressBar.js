import React, { memo, useEffect } from 'react';
import PropTypes from 'prop-types';
import Animated, {
    useSharedValue,
    useAnimatedStyle,
    interpolate,
    useDerivedValue,
    withTiming,
    withDelay,
    runOnJS,
} from 'react-native-reanimated';
import ProgressBar from 'react-native-progress/Bar';
import { View, HelperStyle, Spacing, Scale } from '../../index';
import Style from './style';
import PROGRESSBAR_STR from './ProgressBarStr';

/**
 * Componente Barra de progreso.
 *
 * @component
 */
const ProgressBAR = (props) => {
    const { animationComplete, onAnimationEnd, progress, style, color } = props;
    const active = animationComplete && progress === 1;
    const valueAnimationPosition = active ? 1 : 0;
    const valueAnimationOpacity = active ? 0 : 1;
    const animationPosition = useSharedValue(valueAnimationPosition);
    const animationOpacity = useSharedValue(valueAnimationOpacity);
    const mainColor = color || HelperStyle.primary.color;
    const colorCircle = { backgroundColor: mainColor };
    useEffect(() => {
        const startAnimation = () => {
            const delay = PROGRESSBAR_STR.duration / 2.5;
            const duration = 300;
            const callBackAnimationPosition = () => {
                if (onAnimationEnd) onAnimationEnd();
            };
            animationPosition.value = withDelay(
                delay,
                withTiming(
                    1,
                    {
                        duration,
                    },
                    () => {
                        runOnJS(callBackAnimationPosition)();
                        animationPosition.value = 0;
                    },
                ),
            );
            animationOpacity.value = withDelay(
                delay,
                withTiming(
                    0,
                    {
                        duration,
                    },
                    () => {
                        animationOpacity.value = 1;
                    },
                ),
            );
        };
        if (animationComplete && progress === 1) {
            startAnimation();
        }
    }, [progress]);

    const renderProgressBar = () => {
        const animationConfig = { duration: PROGRESSBAR_STR.duration };
        const ProgressBarStyle = animationComplete ? { zIndex: 2 } : style;
        return (
            <ProgressBar
                height={Spacing.spacer_1}
                animated
                useNativeDriver
                width={null}
                borderColor="transparent"
                borderWidth={0}
                borderRadius={Spacing.radius_3}
                unfilledColor={HelperStyle.gray_lighter.color}
                animationConfig={animationConfig}
                {...props}
                color={mainColor}
                style={ProgressBarStyle}
            />
        );
    };

    const circleStyleLeft = {
        ...Style.circle,
        ...HelperStyle.r_0,
        ...colorCircle,
    };

    const circleStyleRight = {
        ...Style.circle,
        ...HelperStyle.l_0,
        ...colorCircle,
    };

    const circleContainer = {
        ...Style.circleContainer,
        left: -Scale(16),
    };
    const circleContainerRight = {
        ...Style.circleContainer,
        right: -Scale(16),
    };

    const GetInterpolate = (range) =>
        useDerivedValue(() =>
            interpolate(animationPosition.value, [0, 1], [0, range]),
        );

    const ranges = {
        left_top: {
            x: GetInterpolate(-Scale(14)),
            y: GetInterpolate(-Spacing.spacer_2),
        },
        left_bottom: {
            x: GetInterpolate(-Scale(14)),
            y: GetInterpolate(Spacing.spacer_2),
        },
        left_middle: {
            x: GetInterpolate(-Scale(20)),
            y: GetInterpolate(0),
        },
        right_top: {
            x: GetInterpolate(Scale(14)),
            y: GetInterpolate(Spacing.spacer_2),
        },
        right_bottom: {
            x: GetInterpolate(Scale(14)),
            y: GetInterpolate(-Spacing.spacer_2),
        },
        right_middle: {
            x: GetInterpolate(Scale(20)),
            y: GetInterpolate(0),
        },
    };

    const animationStyleLeftTop = useAnimatedStyle(() => ({
        transform: [
            { translateY: ranges.left_top.y.value },
            { translateX: ranges.left_top.x.value },
        ],
        opacity: animationOpacity.value,
    }));

    const animationStyleLeftBottom = useAnimatedStyle(() => ({
        transform: [
            { translateY: ranges.left_bottom.y.value },
            { translateX: ranges.left_bottom.x.value },
        ],
        opacity: animationOpacity.value,
    }));

    const animationStyleLeftMiddle = useAnimatedStyle(() => ({
        transform: [
            { translateY: ranges.left_middle.y.value },
            { translateX: ranges.left_middle.x.value },
        ],
        opacity: animationOpacity.value,
    }));

    const animationStyleRightTop = useAnimatedStyle(() => ({
        transform: [
            { translateY: ranges.right_top.y.value },
            { translateX: ranges.right_top.x.value },
        ],
        opacity: animationOpacity.value,
    }));

    const animationStyleRightBottom = useAnimatedStyle(() => ({
        transform: [
            { translateY: ranges.right_bottom.y.value },
            { translateX: ranges.right_bottom.x.value },
        ],
        opacity: animationOpacity.value,
    }));

    const animationStyleRightMiddle = useAnimatedStyle(() => ({
        transform: [
            { translateY: ranges.right_middle.y.value },
            { translateX: ranges.right_middle.x.value },
        ],
        opacity: animationOpacity.value,
    }));

    if (animationComplete) {
        return (
            <View style={style}>
                <View style={circleContainer}>
                    <Animated.View
                        style={[circleStyleLeft, animationStyleLeftTop]}
                    />
                    <Animated.View
                        style={[circleStyleLeft, animationStyleLeftBottom]}
                    />
                    <Animated.View
                        style={[circleStyleLeft, animationStyleLeftMiddle]}
                    />
                </View>
                {renderProgressBar()}
                <View style={circleContainerRight}>
                    <Animated.View
                        style={[circleStyleRight, animationStyleRightTop]}
                    />
                    <Animated.View
                        style={[circleStyleRight, animationStyleRightBottom]}
                    />
                    <Animated.View
                        style={[circleStyleRight, animationStyleRightMiddle]}
                    />
                </View>
            </View>
        );
    }
    return renderProgressBar();
};

ProgressBAR.propTypes = {
    /**
     * Boleano para activar animación al llegar al 100%.
     */
    animationComplete: PropTypes.bool,
    /**
     * Función que se invoca cuando animationComplete es true y la animación haya finalizado.
     */
    onAnimationEnd: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
    /**
     * Numero entre 0 y 1 que indica el progreso.
     */
    progress: PropTypes.number,
    style: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
    /**
     * Color de la barra de progreso.
     */
    color: PropTypes.string,
    /**
     * Identificador para pruebas.
     */
    testID: PropTypes.string,
    /**
     * Identificador para accesibilidad.
     */
    accessibilityLabel: PropTypes.string,
    /**
     * Sugerencia de accesibilidad que ayuda a los usuarios a comprender qué sucederá cuando realicen una acción.
     */
    accessibilityHint: PropTypes.string,
    /**
     * Comunica el propósito de un componente al usuario.
     */
    accessibilityRole: PropTypes.string,
};
ProgressBAR.defaultProps = {
    animationComplete: false,
    onAnimationEnd: false,
    progress: 0,
    style: {},
    color: '',
    testID: '',
    accessibilityLabel: '',
    accessibilityHint: '',
    accessibilityRole: PROGRESSBAR_STR.accessibilityRole,
};

export default memo(ProgressBAR);
