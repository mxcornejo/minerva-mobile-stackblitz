import React, { memo, useState, useMemo } from 'react';
import { size, toNumber, has, get } from 'lodash';
import { SwipeListView } from 'react-native-swipe-list-view';
import { View } from '../../index';
import SwipeListButton from './SwipeListButton';
import Style from './style';
import { propTypesSwipeListView, defaultPropsSwipeListView } from './type';

/**
 * Componente listado ver mas opciones con gesto deslizar.
 *
 * @component
 */
const SwipeListViewBCH = (props) => {
    const {
        buttonWidth,
        data,
        hiddenItemLeft,
        hiddenItemRight,
        leftOpenValue,
        renderHiddenItem,
        renderItem,
        rightOpenValue,
        styleBackgroundItem,
        swipeGestureBegan,
        keyExtractor,
    } = props;

    /*
     * Se utiliza una rÃ©plica de data para no mutar las props
     */
    const getDataMemo = () =>
        data.map((item, index) => ({
            ...item,
            keyExtractorID:
                item.key || keyExtractor
                    ? keyExtractor(item, index)
                    : `${index}-swipeRow`,
        }));

    const dataMemo = useMemo(getDataMemo, [data, keyExtractor]);

    const [numberOfhiddenItemRight, setnumberOfhiddenItemRight] = useState(
        size(hiddenItemRight),
    );
    const [numberOfhiddenItemLeft, setnumberOfhiddenItemLeft] = useState(
        size(hiddenItemLeft),
    );

    /*
     * Calcula el valor de TranslateX para abrir la fila a la derecha
     */
    const handlerRightOpenValue = () => {
        if (rightOpenValue) {
            return rightOpenValue;
        }
        if (hiddenItemRight) {
            return toNumber(`-${buttonWidth * numberOfhiddenItemRight}`);
        }
        return rightOpenValue;
    };

    /*
     * Calcula el valor de TranslateX para abrir la fila a la izquierda
     */
    const handlerLeftOpenValue = () => {
        if (leftOpenValue) {
            return leftOpenValue;
        }
        if (hiddenItemLeft) {
            return toNumber(`${buttonWidth * numberOfhiddenItemLeft}`);
        }
        return leftOpenValue;
    };

    /*
     * Construye los botones ocultos
     */
    const renderButtons = (
        itemButton,
        indexButton,
        itemData,
        indexData,
        direction,
    ) => {
        const firstItem = indexButton === 0;
        const key = `swipe-btn-${direction}-${indexData}-${indexButton}`;
        const handlerOnPress = () =>
            itemButton?.onPress && itemButton.onPress(itemData, indexData);
        const numberOfButtons =
            direction === 'right'
                ? numberOfhiddenItemRight
                : numberOfhiddenItemLeft;
        return (
            <SwipeListButton
                direction={direction}
                firstItem={firstItem}
                index={indexButton}
                key={key}
                numberOfButtons={numberOfButtons}
                buttonWidth={buttonWidth}
                {...itemButton}
                testID={itemButton?.testID || key}
                onPress={handlerOnPress}
            />
        );
    };

    /*
     * Determina que boton renderizar (right):
     *   - props.hiddenItemRight: renderiza los mismo botones para cada item
     *   - props.data.hiddenItemRight: renderiza botones personalizados para cada item
     */
    const handlerRenderHiddenItemRight = ({ item, index }) => {
        if (has(item, 'hiddenItemRight')) {
            return item.hiddenItemRight.map((btnItem, btnIndex) =>
                renderButtons(btnItem, btnIndex, item, index, 'right'),
            );
        }
        if (hiddenItemRight) {
            return hiddenItemRight.map((btnItem, btnIndex) =>
                renderButtons(btnItem, btnIndex, item, index, 'right'),
            );
        }
        return null;
    };

    /*
     * Determina que boton renderizar (left):
     *   - props.hiddenItemLeft: renderiza los mismo botones para cada item
     *   - props.data.hiddenItemLeft: renderiza botones personalizados para cada item
     */
    const handlerRenderHiddenItemLeft = ({ item, index }) => {
        if (has(item, 'hiddenItemLeft')) {
            return item.hiddenItemLeft.map((btnItem, btnIndex) =>
                renderButtons(btnItem, btnIndex, item, index, 'left'),
            );
        }
        if (hiddenItemLeft) {
            return hiddenItemLeft.map((btnItem, btnIndex) =>
                renderButtons(btnItem, btnIndex, item, index, 'left'),
            );
        }
        return null;
    };

    /*
     * Maneja el tipo de renderizado de hiddenItem
     * si renderHiddenItem retorna renderHiddenItem personalizado
     * si hiddenItemRight o hiddenItemLeft esta definido renderiza SwipeListButton
     */
    const handlerRenderHiddenItem = ({ item, index }) => {
        if (!get(item, 'isSwipeItem', true)) {
            return item.isSwipeItem;
        }
        if (renderHiddenItem) return renderHiddenItem({ item, index });
        if (
            has(item, 'hiddenItemRight') ||
            hiddenItemRight ||
            has(item, 'hiddenItemLeft') ||
            hiddenItemLeft
        ) {
            return (
                <View style={Style.rowBack}>
                    {handlerRenderHiddenItemRight({ item, index })}
                    {handlerRenderHiddenItemLeft({ item, index })}
                </View>
            );
        }
        return false;
    };

    /*
     * Renderiza los elementos de la lista
     */
    const handlerRenderItem = ({ item, index }) => (
        <>
            {renderItem({ item, index })}
            <View
                pointerEvent="none"
                style={[Style.backgroundItem, styleBackgroundItem]}
            />
        </>
    );

    /*
     * Determina la cantidad de botones de cada lado (right/left)
     * Si props.data.itemHashiddenItemRight esta definido toma la dimension de este arreglo para la cantidad de botones
     */
    const handlerSwipeGestureBegan = (rowId) => {
        const arrayIndex = dataMemo.findIndex(
            (item) => item.keyExtractorID === rowId,
        );
        if (swipeGestureBegan) swipeGestureBegan(rowId);

        /*
         * Si props.data.itemHashiddenItemRight esta definido toma la dimension de este arreglo para actualizar la cantidad de botones en right
         */
        const itemHashiddenItemRight = get(
            dataMemo[arrayIndex],
            'hiddenItemRight',
            false,
        );
        if (itemHashiddenItemRight) {
            setnumberOfhiddenItemRight(size(itemHashiddenItemRight));
        } else {
            setnumberOfhiddenItemRight(size(hiddenItemRight));
        }
        /*
         * Si props.data.hiddenItemLeft esta definido toma la dimension de este arreglo para actualizar la cantidad de botones en right
         */
        const itemHashiddenItemLeft = get(
            dataMemo[arrayIndex],
            'hiddenItemLeft',
            false,
        );
        if (itemHashiddenItemLeft) {
            setnumberOfhiddenItemLeft(size(itemHashiddenItemLeft));
        } else {
            setnumberOfhiddenItemLeft(size(hiddenItemLeft));
        }
    };

    const handlerKeyExtractor = (item) => item.keyExtractorID;

    return (
        <SwipeListView
            {...props}
            data={dataMemo}
            keyExtractor={handlerKeyExtractor}
            swipeGestureBegan={handlerSwipeGestureBegan}
            renderItem={handlerRenderItem}
            rightOpenValue={handlerRightOpenValue()}
            leftOpenValue={handlerLeftOpenValue()}
            renderHiddenItem={handlerRenderHiddenItem}
        />
    );
};

SwipeListViewBCH.propTypes = {
    buttonWidth: propTypesSwipeListView.buttonWidth,
    data: propTypesSwipeListView.data,
    hiddenItemLeft: propTypesSwipeListView.hiddenItemLeft,
    hiddenItemRight: propTypesSwipeListView.hiddenItemRight,
    leftOpenValue: propTypesSwipeListView.leftOpenValue,
    renderHiddenItem: propTypesSwipeListView.renderHiddenItem,
    renderItem: propTypesSwipeListView.renderItem.isRequired,
    rightOpenValue: propTypesSwipeListView.rightOpenValue,
    swipeGestureBegan: propTypesSwipeListView.swipeGestureBegan,
    keyExtractor: propTypesSwipeListView.keyExtractor,
    styleBackgroundItem: propTypesSwipeListView.styleBackgroundItem,
    closeOnRowPress: propTypesSwipeListView.closeOnRowPress,
    closeOnRowOpen: propTypesSwipeListView.closeOnRowOpen,
    closeOnRowBeginSwipe: propTypesSwipeListView.closeOnRowBeginSwipe,
    closeOnScroll: propTypesSwipeListView.closeOnScroll,
    disableLeftSwipe: propTypesSwipeListView.disableLeftSwipe,
    disableRightSwipe: propTypesSwipeListView.disableRightSwipe,
    recalculateHiddenLayout: propTypesSwipeListView.recalculateHiddenLayout,
    swipeGestureEnded: propTypesSwipeListView.swipeGestureEnded,
    onRowOpen: propTypesSwipeListView.onRowOpen,
    onRowDidOpen: propTypesSwipeListView.onRowDidOpen,
    onRowClose: propTypesSwipeListView.onRowClose,
    onRowDidClose: propTypesSwipeListView.onRowDidClose,
    onLeftActionStatusChange: propTypesSwipeListView.onLeftActionStatusChange,
    onRightActionStatusChange: propTypesSwipeListView.onRightActionStatusChange,
    onLeftAction: propTypesSwipeListView.onLeftAction,
    onRightAction: propTypesSwipeListView.onRightAction,
    onScrollEnabled: propTypesSwipeListView.onScrollEnabled,
    swipeRowStyle: propTypesSwipeListView.swipeRowStyle,
    onSwipeValueChange: propTypesSwipeListView.onSwipeValueChange,
    useNativeDriver: propTypesSwipeListView.useNativeDriver,
    useAnimatedList: propTypesSwipeListView.useAnimatedList,
};
SwipeListViewBCH.defaultProps = {
    buttonWidth: defaultPropsSwipeListView.buttonWidth,
    data: defaultPropsSwipeListView.data,
    hiddenItemLeft: defaultPropsSwipeListView.hiddenItemLeft,
    hiddenItemRight: defaultPropsSwipeListView.hiddenItemRight,
    leftOpenValue: defaultPropsSwipeListView.leftOpenValue,
    renderHiddenItem: defaultPropsSwipeListView.renderHiddenItem,
    rightOpenValue: defaultPropsSwipeListView.rightOpenValue,
    swipeGestureBegan: defaultPropsSwipeListView.swipeGestureBegan,
    keyExtractor: defaultPropsSwipeListView.keyExtractor,
    styleBackgroundItem: defaultPropsSwipeListView.styleBackgroundItem,
    closeOnRowBeginSwipe: defaultPropsSwipeListView.closeOnRowBeginSwipe,
    closeOnScroll: defaultPropsSwipeListView.closeOnScroll,
    closeOnRowPress: defaultPropsSwipeListView.closeOnRowPress,
    closeOnRowOpen: defaultPropsSwipeListView.closeOnRowOpen,
    disableLeftSwipe: defaultPropsSwipeListView.disableLeftSwipe,
    disableRightSwipe: defaultPropsSwipeListView.disableRightSwipe,
    recalculateHiddenLayout: defaultPropsSwipeListView.recalculateHiddenLayout,
    swipeGestureEnded: defaultPropsSwipeListView.swipeGestureEnded,
    onRowOpen: defaultPropsSwipeListView.onRowOpen,
    onRowDidOpen: defaultPropsSwipeListView.onRowDidOpen,
    onRowClose: defaultPropsSwipeListView.onRowClose,
    onRowDidClose: defaultPropsSwipeListView.onRowDidClose,
    onLeftActionStatusChange:
        defaultPropsSwipeListView.onLeftActionStatusChange,
    onRightActionStatusChange:
        defaultPropsSwipeListView.onRightActionStatusChange,
    onLeftAction: defaultPropsSwipeListView.onLeftAction,
    onRightAction: defaultPropsSwipeListView.onRightAction,
    onScrollEnabled: defaultPropsSwipeListView.onScrollEnabled,
    swipeRowStyle: defaultPropsSwipeListView.swipeRowStyle,
    onSwipeValueChange: defaultPropsSwipeListView.onSwipeValueChange,
    useNativeDriver: defaultPropsSwipeListView.useNativeDriver,
    useAnimatedList: defaultPropsSwipeListView.useAnimatedList,
};

export default memo(SwipeListViewBCH);
