import React, { memo, useState, useRef, useEffect } from 'react';
import { Animated } from 'react-native';
import Carousel from 'react-native-snap-carousel';
import { size, isFunction, isBoolean } from 'lodash';
import { dimensions, HelperStyle, View, Pagination } from '../../index';
import BackgroundAnimation from './components/BackgroundAnimation';
import ButttonLastItem from './components/ButtonLastItem';
import CAROUSEL_STR from './CarouselStr';
import {
    defaultSliderHeight,
    defaultSliderWidth,
    defaultItemWidth,
    getFormatData,
} from './utils';
import { carouselPropTypes, carouselDefaultProps } from './types';

/**
 * Componente Carousel de componentes.
 *
 * @component
 */
const CarouselBCH = (props) => {
    const {
        backgroundAnimation,
        contentContainerCustomStyle,
        itemWidth,
        sliderHeight,
        sliderWidth,
        data,
        activeSlideAlignment,
        carouselStyle,
        renderItem,
        containerItem,
        onSnapToItem,
        pagination,
        firstItem,
        refCarousel,
        maxItems,
        renderMaxItems,
        maxItemsButton,
        error,
        renderError,
        loading,
        renderLoading,
        containerItemStyle,
    } = props;
    const [slideActive, setSlideActive] = useState(firstItem);
    const [animation] = useState(new Animated.Value(0));
    const [width, setWidth] = useState(0);
    const onLayout = (event) => setWidth(event.nativeEvent.layout.width);
    let carouselProductoRef = useRef(null);
    carouselProductoRef = refCarousel || carouselProductoRef;
    const isRenderMaxItems = (index) =>
        index === parseInt(maxItems, 10) && maxItemsButton;
    const formatData = getFormatData(data, maxItems, maxItemsButton);
    const dataSize = size(formatData);
    const onlyChild = dataSize === 1;
    const getSize = (customSize, defaultSize) => customSize || defaultSize;

    /**
     * Actualiza el activo del paginador si la data se actualiza.
     */
    useEffect(() => {
        const active = slideActive + 1;
        if (active >= dataSize && dataSize - 1 !== -1) {
            setSlideActive(dataSize - 1);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [data]);

    /**
     * Renderiza componente máximo de items (ButttonLastItem/renderMaxItems).
     *
     * @param {string} align - Alineación del slider (para calcular el margen del button).
     */
    const handlerRenderMaxItems = (align) => {
        if (isFunction(renderMaxItems)) return renderMaxItems();
        return (
            <ButttonLastItem
                activeSlideAlignment={align}
                {...maxItemsButton}
                testID={maxItemsButton?.testID}
                accessibilityLabel={maxItemsButton?.accessibilityLabel}
                accessibilityHint={maxItemsButton?.accessibilityHint}
            />
        );
    };

    /**
     * Condiciona el renderizado de los items del carousel.
     * Sí maxItems esta definido llama a handlerRenderMaxItems().
     */
    const handlerRenderItem = ({ item, index }) => {
        if (isRenderMaxItems(index)) return handlerRenderMaxItems();
        return renderItem({ item, index });
    };

    /**
     * Actualiza el estado del paginador (slideActive) si la propiedad pagination esta definida.
     *
     * @param {number} active - Indice del slide activo.
     */
    const handleOnSnapToItem = (active) => {
        if (pagination) {
            setSlideActive(active);
        }
        if (onSnapToItem) {
            onSnapToItem(active);
        }
    };

    /**
     * Propiedades del carouselStyle Card.
     */
    const getCardTheme = () => {
        const mh4 = { ...HelperStyle.ml_4, ...HelperStyle.mr_4 };
        const mh1 = { ...HelperStyle.ml_1, ...HelperStyle.mr_1 };
        const mh2 = { ...HelperStyle.ml_2, ...HelperStyle.mr_2 };
        const SlideAlignmentStyle =
            activeSlideAlignment === CAROUSEL_STR.defaultActiveSlideAlignment &&
            !onlyChild &&
            HelperStyle.ml_2;
        const getItemWidth = onlyChild
            ? dimensions.fullWidth
            : defaultItemWidth;
        const getContainerItem = isBoolean(containerItem)
            ? containerItem
            : true;
        /**
         * Condiciona el margen de los slide dependiendo de la cantidad de items.
         * Sí data es igual a 1 margen es mh4.
         * Sí data es diferente a 1 margen es mh1.
         */
        const getCardItemtyle = () => {
            let styleCard = onlyChild ? mh4 : mh1;
            if (
                !onlyChild &&
                activeSlideAlignment ===
                    CAROUSEL_STR.defaultActiveSlideAlignment
            )
                styleCard = mh2;
            return styleCard;
        };
        /**
         * Condiciona el renderizado de los items del carousel tipo card.
         * Sí maxItems esta definido llama a handlerRenderMaxItems().
         */
        const handlerRenderItemCard = ({ item, index }) => {
            if (isRenderMaxItems(index)) {
                return handlerRenderMaxItems(activeSlideAlignment);
            }
            if (getContainerItem) {
                return (
                    <View
                        accessible={false}
                        style={[getCardItemtyle(), containerItemStyle]}
                        testID={`${CAROUSEL_STR.containerItemTestID}-${index}`}
                    >
                        {renderItem({ item, index })}
                    </View>
                );
            }
            return renderItem({ item, index });
        };

        return {
            // INICIO: Propiedades que se pueden sobreescribir
            scrollEnabled: !onlyChild,
            inactiveSlideOpacity: 1,
            inactiveSlideScale: 1,
            removeClippedSubviews: false,
            ...props,
            // INICIO: Propiedades que no se deben sobreescribir
            activeSlideAlignment,
            contentContainerCustomStyle: [
                HelperStyle.ai_s,
                SlideAlignmentStyle,
                contentContainerCustomStyle,
            ],
            renderItem: handlerRenderItemCard,
            data: formatData,
            onSnapToItem: handleOnSnapToItem,
            ref: carouselProductoRef,
            sliderWidth: getSize(sliderWidth, defaultSliderWidth),
            sliderHeight: getSize(sliderHeight, defaultSliderHeight),
            itemWidth: getSize(itemWidth, getItemWidth),
        };
    };

    /**
     * Obtiene las props dependiendo del tema dependiendo del valor de carouselStyle [default, card].
     */
    const getThemeProps = () => {
        // tema: default slider
        let themeProps = {
            ...props,
            data: formatData,
            renderItem: handlerRenderItem,
            onSnapToItem: handleOnSnapToItem,
            ref: carouselProductoRef,
            sliderWidth: getSize(sliderWidth, defaultSliderWidth),
            sliderHeight: getSize(sliderHeight, defaultSliderHeight),
            itemWidth: getSize(itemWidth, defaultItemWidth),
        };
        // team: card Slider
        if (carouselStyle === 'card') themeProps = getCardTheme();
        return themeProps;
    };

    const defaultThemeProps = getThemeProps();

    /**
     * Renderiza componente <Pagination /> si la propiedad pagination esta definida.
     */
    const getPaginator = () => {
        if (pagination) {
            return (
                <Pagination
                    dotsLength={dataSize}
                    activeDotIndex={slideActive}
                    {...pagination}
                />
            );
        }
        return null;
    };

    const renderBackgroundAnimation = () => (
        <BackgroundAnimation animation={animation} data={data} width={width}>
            <Carousel
                {...defaultThemeProps}
                onScroll={Animated.event(
                    [{ nativeEvent: { contentOffset: { x: animation } } }],
                    {
                        useNativeDriver: true,
                    },
                )}
                onLayout={onLayout}
            />
            {getPaginator()}
        </BackgroundAnimation>
    );

    const renderPagination = () => (
        <View>
            <Carousel {...defaultThemeProps} />
            {getPaginator()}
        </View>
    );

    const renderType = () => {
        const typesRenders = {
            loading,
            error,
            backgroundAnimation,
            pagination,
        };
        const typeRender = Object.keys(typesRenders).find(
            (i) => typesRenders[i] === true,
        );
        switch (typeRender) {
            case 'loading':
                return renderLoading();
            case 'error':
                return renderError();
            case 'backgroundAnimation':
                return renderBackgroundAnimation();
            case 'pagination':
                return renderPagination();
            default:
                return <Carousel {...defaultThemeProps} />;
        }
    };

    return renderType();
};

CarouselBCH.propTypes = carouselPropTypes;
CarouselBCH.defaultProps = carouselDefaultProps;

export default memo(CarouselBCH);
