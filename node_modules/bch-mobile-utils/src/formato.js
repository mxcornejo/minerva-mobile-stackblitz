import { padStart } from 'lodash';
import { PRODUCTS } from 'bch-mobile-constants';
import capitalize from 'lodash/capitalize';

const regexMail = /(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])/;
const regexSpecialChars = /[^a-zA-Z0-9ñÑáéíóúÁÉÍÓÚ\s\.\,\/]/;

const cleanNumber = (number) => {
    return number.toString().replace(/[., -]/g, '');
};

const cleanAmount = (number) => {
    return number.toString().replace(/\D/g, '');
};

const cleanInput = (number) => {
    return number.replace(/([^0-9,])/g, '');
};

const cleanMontoUS = (valor) => {
    if (valor) {
        const monto = valor.toString().replace('.', ',');
        return monto;
    }
    return '';
};

const checkIsValidValue = (value = null) => value !== '' && value !== null;

const isNegativeValue = (value) => value < 0 || 1/value === -Infinity;

/**
 * Funcion que a partir de un valor retorna
 * este valor formateado en miles
 * Se agrega validacion de monto menor a 0
 * para agregar signo negativo
 * @param {*} valor
 */
const monto = (valor) => {
    if (valor) {
        const valorNumber = parseInt(valor);
        const number = valor.toString().replace(/[., -]/g, '');
        const format = number.replace(/\B(?=(\d{3})+(?!\d))/g, '.');
        return isNegativeValue(valorNumber) ? `-${format}` : format;
    }
    return '';
};

const montoMoneda = (valor) => {
    if (typeof valor !== 'undefined' && valor !== null) {
        const number = valor.toString();
        if (number === '0') return '$0';
        if (valor < 0) {
            const numberFormateado = number.replace("-", "");
            return `-$${numberFormateado.replace(/\B(?=(\d{3})+(?!\d))/g, '.')}`;
        }
        return `$${number.replace(/\B(?=(\d{3})+(?!\d))/g, '.')}`;
    }
    return '$-';
};

const montoStringToFloat = (valor) => {
    if (valor) {
        const number = valor.replace(/\./g, '');
        return parseFloat(number.replace(',', '.'));
    }
    return '';
};

const montoInt = (valor, cantidadDecimales = 2) => {
    if (typeof valor !== 'undefined' && valor !== null) {
        let newNumber = valor.toString().replace('.', ',').split(',');
        if (!newNumber[0]) newNumber[0] = '0';
        if (!newNumber[1]) {
            newNumber[1] = '00';
        } else {
            if (newNumber[1].length === 1) {
                newNumber[1] = newNumber[1] + '0';
            }
            if (newNumber[1].length > cantidadDecimales) {
                newNumber[1] = newNumber[1].substring(0, cantidadDecimales);
            }
        }
        return `${monto(newNumber[0])},${newNumber[1]}`;
    }
    return valor;
};

/**
 * Funcion que permite anteponer el el tipo de moneda
 * @param {*} valor string
 * @param {*} moneda se debe enviar el string de moneda sin signo peso
 * Correcto: USD
 * No Correcto: USD $
 */
const moneda = (valor = '-', moneda) => {
    if (moneda) {
        if (valor && valor !== '-' && valor[0] === '-') {
            return `${moneda} -$${valor.replace('-', '')}`
        }
        return `${moneda} $${valor}`;
    }
    return `$${valor}`;
};


const montoMonedaLCD = (valor) => {
    if (valor) {
        const number = valor.toString().replace(/\D/g, '');
        return `$${number.replace(/\B(?=(\d{3})+(?!\d))/g, '.')}`;
    }
    return '';
};

const descripcionProducto = (codigoProducto, claseCuenta) => {
    let descripcion = '';
    const getJUVdescripcion = () => {
        switch (claseCuenta) {
            case PRODUCTS.CLASS_ACCOUNT.VTACNN:
                return PRODUCTS.NAME_PRODUCT.CUENTA_FAN;
            case PRODUCTS.CLASS_ACCOUNT.CVISTA:
                return PRODUCTS.NAME_PRODUCT.CUENTA_VISTA;
            case PRODUCTS.CLASS_ACCOUNT.CVICCH:
                return PRODUCTS.NAME_PRODUCT.CUENTA_VISTA;
            default:
                return PRODUCTS.NAME_PRODUCT.CUENTA_VISTA;
        }
    };

    switch (codigoProducto) {
        case PRODUCTS.CODE_PRODUCT.CTD:
            descripcion = PRODUCTS.NAME_PRODUCT.CUENTA_CORRIENTE;
            if (claseCuenta === PRODUCTS.CLASS_ACCOUNT.CVISTA) {
                descripcion = PRODUCTS.NAME_PRODUCT.CUENTA_VISTA;
            }
            break;
        case PRODUCTS.CODE_PRODUCT.TNM:
            descripcion = PRODUCTS.NAME_PRODUCT.TARJETA_CREDITO;
            break;
        case PRODUCTS.CODE_PRODUCT.LCD:
            descripcion = PRODUCTS.NAME_PRODUCT.LINEA_CREDITO;
            break;
        case PRODUCTS.CODE_PRODUCT.RTV:
            descripcion = PRODUCTS.NAME_PRODUCT.TARJETA_CREDITO;
            break;
        case PRODUCTS.CODE_PRODUCT.CEX:
            descripcion = PRODUCTS.NAME_PRODUCT.CUENTA_CORRIENTE_ME;
            break;
        case PRODUCTS.CODE_PRODUCT.AHO:
            descripcion = PRODUCTS.NAME_PRODUCT.CUENTA_AHORRO;
            break;
        case PRODUCTS.CODE_PRODUCT.JUV:
            descripcion = getJUVdescripcion();
            break;
        default:
            break;
    }

    return descripcion;
};

const descripcionProductoPorTipo = (tipoProducto) => {
    const {
        PRODUCT_TYPE: {
            PRODUCT_CC,
            PRODUCT_CV,
            PRODUCT_CF,
            PRODUCT_CC_ME,
            PRODUCT_CA,
            PRODUCT_LC,
            PRODUCT_TC,
        },
        NAME_PRODUCT: {
            CUENTA_CORRIENTE,
            CUENTA_VISTA,
            CUENTA_FAN,
            CUENTA_CORRIENTE_ME,
            CUENTA_AHORRO,
            LINEA_CREDITO,
            TARJETA_CREDITO,
        },
    } = PRODUCTS;

    switch (tipoProducto) {
        case PRODUCT_CC:
            return CUENTA_CORRIENTE;
        case PRODUCT_CV:
            return CUENTA_VISTA;
        case PRODUCT_CF:
            return CUENTA_FAN;
        case PRODUCT_CC_ME:
            return CUENTA_CORRIENTE_ME;
        case PRODUCT_CA:
            return CUENTA_AHORRO;
        case PRODUCT_LC:
            return LINEA_CREDITO;
        case PRODUCT_TC:
            return TARJETA_CREDITO;
        default:
            return '';
    }
};

const descripcionProductoCorta = (codigoProducto, claseCuenta) => {
    let descripcion = '';
    if (codigoProducto === 'CTD') {
        switch (claseCuenta) {
            case 'CVISTA': descripcion = 'CV'; break;
            case 'CVICCH': descripcion = 'CV'; break;
            default: descripcion = 'CC'; break;
        }
    }
    if (codigoProducto === 'JUV') {
        descripcion = 'CV';
    }
    if (codigoProducto === 'TNM') {
        descripcion = 'TC';
    }
    return descripcion;
};

const numeroProducto = (numProducto) => {
    const grupos = [2, 3, 5, 2];
    let numeroProducto = numProducto;
    let result = '';
    numeroProducto = numeroProducto ? String(numeroProducto).replace(/[^\d]/g, '') : '';
    numeroProducto = padStart(numeroProducto, 13, '0');
    for (let i = grupos.length - 1; i >= 0; i -= 1) {
        const g = grupos[i];
        const codePart = numeroProducto.substring(numeroProducto.length - g);
        result = `-${codePart}${result}`;
        numeroProducto = numeroProducto.substring(0, numeroProducto.length - g);
    }
    return `${result.substring(1)}`;
};

const numeroProductoOfuscado = (numProducto, numero) => {
    if (numProducto) {
        return `****${numProducto.substring(numProducto.length - numero, numProducto.length)}`;
    }
    return numProducto;
};

/*
* Setea la titularidad de una tarjeta de crédito.
*/

const titularidadTNM = (codigo) => {
    const codigoAdicional = 'A';
    if (codigo === codigoAdicional) {
        return 'Adicional';
    }
    return 'Titular';
};

/*
* Capitaliza todas las palabras de una frase.
*/
const allWordsCapitalize = (phrase) => {
    const allWordsInText = phrase.toLowerCase().split(' ').map(s => capitalize(s)).join(' ');
    return allWordsInText;
};

const nombreTipoCuentaCorto = (TipoCuenta) => {
    let cuenta = '';
    switch (TipoCuenta) {
        case PRODUCTS.NAME_PRODUCT.CUENTA_CORRIENTE:
            cuenta = PRODUCTS.SHORT_NAME_ACCOUNT.CUENTA_CORRIENTE;
            break;
        case PRODUCTS.NAME_PRODUCT.CUENTA_VISTA:
            cuenta = PRODUCTS.SHORT_NAME_ACCOUNT.CUENTA_VISTA;
            break;
        case PRODUCTS.NAME_PRODUCT.CUENTA_AHORRO:
            cuenta = PRODUCTS.SHORT_NAME_ACCOUNT.CUENTA_AHORRO;
            break;
        default:
            break;
    }
    return cuenta;
};

const validaRut = (rut) => {
    const rutRaw = rut.replace(/\./g, '').replace('-', '');
    const cuerpo = rutRaw.slice(0, -1);
    let dv = rutRaw.slice(-1).toUpperCase();
    let suma = 0;
    let multiplo = 2;

    for (let i = 1; i <= cuerpo.length; i += 1) {
        suma += (multiplo * rutRaw.charAt(cuerpo.length - i));
        if (multiplo < 7) {
            multiplo += 1;
        } else {
            multiplo = 2;
        }
    }
    const dvEsperado = 11 - (suma % 11);
    // Casos Especiales (0 y K)
    dv = (dv === 'K') ? 10 : parseInt(dv, 10);
    dv = (dv === 0) ? 11 : parseInt(dv, 10);

    if (dv !== dvEsperado) {
        return false;
    }
    return true;
};

const formatRut = (rut) => {
    if (rut === '') {
        return '';
    }
    if (rut.length === 1 || (rut.length === 2 && rut.includes('-'))) {
        return rut.replace('-', '');
    }
    let rutLimpio = rut.replace(/^0+/, '');
    let rutFormateado = '';
    rutLimpio = rutLimpio.replace(/[-|\.]/g, '');
    const dv = rutLimpio.charAt(rutLimpio.length - 1);
    rutLimpio = rutLimpio.substring(0, rutLimpio.length - 1);
    while (rutLimpio.length > 3) {
        rutFormateado = `.${rutLimpio.substr(rutLimpio.length - 3)}${rutFormateado}`;
        rutLimpio = rutLimpio.substring(0, rutLimpio.length - 3);
    }
    rutFormateado = `${rutLimpio}${rutFormateado}-${dv}`;
    return rutFormateado;
};

/*
* Validar el largo de mantiza de un rut.
*/
const validLargeRut = (rut) => {
    const cleanDotHyphen = rut.replace(/[.-]/g, '');
    return cleanDotHyphen.length > 6 && cleanDotHyphen.length < 10
};

const validaEmail = (email) => regexMail.test(email);

const validaSpecialChars = (text) => {
    return !regexSpecialChars.test(text);
};

/*
 * Params:
 * @valor string con valor a formatear
 * @largo int con largo del string valor a mostrar
 * @token string con token a agregar en la cadena
 * @largoToken int con cantidad de repeticiones del token
 * ______
 * Ejemplo de uso obfuscatedNumberFormat('123123123', 4, '*', 2);
 * Resultado "**3123"
 */
const obfuscatedNumberFormat = (valor, largo, token, largoToken) => {
    let cadena = '';
    if (token && largoToken) {
        cadena = token.repeat(largoToken);
    }
    if (valor) {
        return `${cadena}${valor.substring(valor.length - largo, valor.length)}`;
    }
    return valor;
};

/*
 * Params:
 * @valor string con valor a formatear
 * ______
 * Ejemplo de uso valorPorcentual(1.74);
 * Resultado "1,74%"
 */
const valorPorcentual = (valor = null) => {
    if (valor !== null) {
        const number = valor.toString().replace('.', ',');
        if (number === '0') return '0%';
        return `${number.replace(/\B(?=(\d{3})+(?!\d))/g, '.')}%`;
    }
    return '-';
};

/*
 * Params:
 * @valor string con valor a formatear
 * ______
 * Ejemplo de uso formatNumberWhiteSpaceCreditCard(0000000000000000);
 * Resultado "0000 0000 0000 0000"
 */
const formatNumberWhiteSpaceCreditCard = (valor = null) => {
    if (valor !== null) {
        return valor.replace(/\s?/g, '').replace(/(\d{4})/g, '$1 ').trim();
    }
    return '-';
};

export default {
    cleanNumber,
    cleanAmount,
    cleanInput,
    cleanMontoUS,
    checkIsValidValue,
    isNegativeValue,
    monto,
    montoInt,
    moneda,
    montoMoneda,
    descripcionProducto,
    descripcionProductoPorTipo,
    descripcionProductoCorta,
    numeroProducto,
    numeroProductoOfuscado,
    montoMonedaLCD,
    montoStringToFloat,
    titularidadTNM,
    allWordsCapitalize,
    nombreTipoCuentaCorto,
    validaRut,
    validLargeRut,
    formatRut,
    validaEmail,
    validaSpecialChars,
    obfuscatedNumberFormat,
    valorPorcentual,
    formatNumberWhiteSpaceCreditCard,
};
