import { PRODUCTS } from 'bch-mobile-constants';
import FormatoFecha from './formatoFecha';
import Formato from './formato';
import SliderStructure from './SliderStructure';
import { getAppSecurityState } from './getCurrentConfigApp';

const {
    NAME_PRODUCT: {
        CUENTA_CORRIENTE,
        CUENTA_CORRIENTE_ME,
        CUENTA_VISTA,
        CUENTA_FAN,
        TARJETA_CREDITO,
    },
    PRODUCT_TYPE: {
        PRODUCT_CF,
    },
    CODE_PRODUCT: {
        TNM,
        RTV,
    },
} = PRODUCTS;

const FILTRO_TARJETAS = [TNM, RTV];

const filterProducts = (dataArray, arrayFilter=[PRODUCTS.CODE_PRODUCT.CTD, PRODUCTS.CODE_PRODUCT.JUV]) => {
    let productList = [];
        productList = dataArray.filter(product => arrayFilter.includes(product.codigoProducto));
    return productList;
};
/**
 * Grupo de fecha
 * @param {object} obj
 */
const groupByDate = (obj) => {
    const grupos = obj.reduce((grupos, item) => {
        const gruposTemp = grupos;
        const date = FormatoFecha.formatDate(item.fechaTransaccion, 'DD [de] MMMM [del] YYYY');
        if (!grupos[date]) {
            gruposTemp[date] = [];
        }
        gruposTemp[date].push(item);
        return gruposTemp;
    }, {});

    return Object.keys(grupos).map(date => ({
        date,
        data: grupos[date],
    }));
};

const groupByMonth = (obj) => {
    const grupos = obj.reduce((grupos, item) => {
        const gruposTemp = grupos;
        const date = FormatoFecha.formatDate(item.fechaPago, 'MMMM [del] YYYY');
        if (!grupos[date]) {
            gruposTemp[date] = [];
        }
        gruposTemp[date].push(item);
        return gruposTemp;
    }, {});

    return Object.keys(grupos).map(date => ({
        date,
        data: grupos[date],
    }));
};

/**
 * Ordena los productos para la lista de cuenta principal
 * @param {object} data Array con los productos candidatos a cuenta principal
 */
const sortSelectMainAccount = (data) => {
    const orderArraySectionList = [];
    data.forEach((cuenta) => {
        const { codigoProducto, claseCuenta } = cuenta;
        const tipoCuenta = Formato.descripcionProducto(codigoProducto, claseCuenta);
        if (CUENTA_CORRIENTE === tipoCuenta) {
            orderArraySectionList.unshift(cuenta);
        }
        if (CUENTA_CORRIENTE_ME === tipoCuenta || CUENTA_FAN === tipoCuenta || CUENTA_VISTA === tipoCuenta || TARJETA_CREDITO === tipoCuenta) {
            orderArraySectionList.push(cuenta);
        }
    });
    return orderArraySectionList.sort((a, b) => ((a.tipoProducto > b.tipoProducto) ? 1 : ((b.tipoProducto > a.tipoProducto) ? -1 : 0)));
};


const setProducts = (product) => {
    const dataArray = Array.from(product.values());
    const resultProduct = filterProducts(dataArray);
    const dataReturn = [];
    resultProduct.forEach((item) => {
        const {
            codigoProducto,
            claseCuenta,
            numProducto,
            dataSaldo,
        } = item;
        if (dataSaldo) {
            const cardHeader = {
                title: Formato.descripcionProducto(codigoProducto, claseCuenta),
                subtitle: Formato.numeroProducto(numProducto),
            };
            const cardBody = SliderStructure('CUENTA_CC_LC', dataSaldo);
            dataReturn.push({ ...cardHeader, ...cardBody });
        }
    });
    return dataReturn;
};

/**
     * Busca el valor corresspondiente dentro de array de objetos
     * @param {string} id ID a buscar
     * @param {array} arrayData Array de objetos
     */
const setItemFromArray = (id, arrayData) => (
    arrayData.find(item => id === (item.id).toString())
);

/**
     * Setea informacion de cuenta para mostrar en listado de contactos
     * @param {obj} bankInfo Informacion de marca de banco
     * @param {obj} accountInfo Informacion de cuenta del contacto
     * @param {string} accountNumber numero de cuenta del contacto
     */
const setAccountInfo = (bankInfo, accountInfo, accountNumber) => (
    `${bankInfo.nombre} - ${accountInfo.nombre} - ${accountNumber}`
);

/**
 * setea los datos para mostrar en el listado
 * @param {array} accounts Array de contactos
 */
const setItemSlider = (accounts, bancos, tiposCuenta) => {
    const contacts = [{ data: [] }];
    let bankInfo = null;
    let accountInfo = null;
    let itemData = {};
    accounts.forEach((item) => {
        bankInfo = setItemFromArray(item.cuentas[0].idBanco, bancos);
        accountInfo = setItemFromArray(item.cuentas[0].tipoCuenta, tiposCuenta);
        itemData = {};
        itemData.alias = item.cuentas[0].alias;
        itemData.nombre = item.nombreRazonSocial;
        itemData.rutCuenta = item.rutBeneficiario;
        itemData.idBanco = bankInfo.id;
        itemData.banco = bankInfo.nombre;
        itemData.tipoCuenta = accountInfo.codigo;
        itemData.tipoCuentaNombre = accountInfo.nombre;
        itemData.numeroCuenta = item.cuentas[0].numeroCuenta;
        itemData.cuenta = setAccountInfo(bankInfo, accountInfo, item.cuentas[0].numeroCuenta);
        contacts[0].data.push(itemData);
    });
    return contacts;
};

const indexByContext = (listaProductos, contexto, filtro) => {
    let index = 0;
    const arrayProductos = Array.from(listaProductos.values());
    const productosFiltrados = arrayProductos.filter(producto => filtro.includes(producto.codigoProducto));
    if (productosFiltrados.length && contexto) {
        index = productosFiltrados.findIndex(elemento => elemento.numProductoEncriptado === contexto.numProductoEncriptado);
    }
    return index;
};

const getProductIdFields = async () => {
    const appSecurityState = await getAppSecurityState();
    const idProductoField = (!appSecurityState.tokenFields) ? 'numProducto' : 'numProductoToken';
    const idProductoRelacionadoField = (!appSecurityState.tokenFields) ? 'cuentaRelacionada' : 'cuentaRelacionaToken';
    return {
        idProductoField,
        idProductoRelacionadoField
    };
}

/**
 * ValidaciÃ³n para que el producto no sea cuenta FAN, devuelve false para que no incluya este producto
 * @param {object} producto
 * @returns true o false
 */
const handleNotCuentaFAN = producto => producto.tipoProducto !== PRODUCT_CF;

/**
 * Validacion para validar si el usuario solo tiene productos CtaFan y TC
 * @param {object} listadoProductos
 * @returns true o false
 */
const handleOnlyTCFAN = (listadoProductos) => {
    const arrayProductos = Array.from(listadoProductos.values());
    const soloFANySoloTC = arrayProductos.filter(producto => !handleNotCuentaFAN(producto) || FILTRO_TARJETAS.includes(producto.codigoProducto));
    return soloFANySoloTC.length === arrayProductos.length;
};

export default {
    filterProducts,
    groupByDate,
    groupByMonth,
    setProducts,
    setItemFromArray,
    setAccountInfo,
    setItemSlider,
    sortSelectMainAccount,
    indexByContext,
    getProductIdFields,
    handleNotCuentaFAN,
    handleOnlyTCFAN,
};
